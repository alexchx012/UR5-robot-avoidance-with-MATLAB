# 基于主动避障的机械臂点到点运动规划实践操作指南

### 初始参数

**网络通信参数 (MATLAB/ROS)**

- Ubuntu VM IP 地址 (示例): 

  ```
  192.168.110.24/43.158
  ```

   (默认值)

  - 定义文件: 章节 5.1.2 的 `connect_to_ros.m` 脚本 (作为用户输入的默认值)

- Windows 主机 IP 地址 (示例): 

  ```
  192.168.110.148/43.21
  ```

   (默认值)

  - 定义文件: 章节 5.1.2 的 `connect_to_ros.m` 脚本 (作为用户输入的默认值)

**2. 机械臂参数 (UR5)**

- D-H 参数及相关尺寸 (UR5):
  - `d1`: 0.089159 m (URDF: d1)
  - `a2`: 0.42500 m (URDF: a2, MATLAB `a` 通常为正值)
  - `a3`: 0.39225 m (URDF: a3, MATLAB `a` 通常为正值)
  - `d4`: 0.10915 m (URDF: d4)
  - `d5`: 0.09465 m (URDF: d5)
  - `d6`: 0.0823 m (URDF: d6)
  - `gripper_base_offset`: 0.030 m (自定义, 与 `create_robot_model.m` 一致)
  - `tcp_offset`: 0.150 m (自定义, 与 `create_robot_model.m` 一致)
  - 注意: URDF中的连杆尺寸 (如 `base_height`, `link_rad` 等) 现在由UR5的URDF文件 (`ur5.urdf.xacro` 及其包含的宏) 定义。
  - 定义文件: 章节 4.3 的 `~/catkin_ws/src/arm_obstacle_avoidance/urdf/custom_arm.urdf.xacro` (集成了UR5模型) 和 `create_robot_model.m` (用于MATLAB模型)。
- 惯性参数 (示例 - 基座):
  - `mass`: 5.0 kg
  - `inertia` (ixx, iyy, izz): 0.1, 0.1, 0.2 (其他分量为0)
  - 定义文件: 章节 4.3 的 `~/catkin_ws/src/arm_obstacle_avoidance/urdf/custom_arm.urdf.xacro` 文件 (在 `<inertial>` 标签内)
- 关节限位 (UR5):
  - `shoulder_pan_joint`: ±2π rad
  - `shoulder_lift_joint`: ±π/2 rad
  - `elbow_joint`: ±0.75π rad
  - `wrist_1_joint`: ±2π rad
  - `wrist_2_joint`: ±2π rad
  - `wrist_3_joint`: ±2π rad
  - 注意: `effort` 和 `velocity` 限制通常在UR5的URDF或 `arm_controllers.yaml` 中定义。
  - 定义文件: 章节 4.3 的 `~/catkin_ws/src/arm_obstacle_avoidance/urdf/custom_arm.urdf.xacro` (通过包含标准UR5模型宏来集成其关节限制) 和 `create_robot_model.m`。
- 控制器参数 (示例):
  - `goal_time`: 0.6 s
  - `stopped_velocity_tolerance`: 0.05 rad/s
  - 关节轨迹/目标容差: 0.1 rad
  - `stop_trajectory_duration`: 0.5 s
  - `state_publish_rate`: 25 Hz
  - `action_monitor_rate`: 10 Hz
  - 定义文件: 章节 4.4 的 `~/catkin_ws/src/arm_obstacle_avoidance/config/arm_controllers.yaml` 文件
- Gazebo中生成位置 (示例):
  - x: 0.6, y: 0.0, z: 0.0 (米)
  - 定义文件: 章节 4.6 的 `~/catkin_ws/src/arm_obstacle_avoidance/launch/arm_gazebo.launch` 文件 (在 `spawn_model` 节点的 `args` 中)
- MATLAB `rigidBodyTree` D-H 参数 (UR5):
  - `d1_val`: 0.089159
  - `a2_val`: 0.42500
  - `a3_val`: 0.39225
  - `d4_val`: 0.10915
  - `d5_val`: 0.09465
  - `d6_val`: 0.0823
  - `gripper_base_offset_val`: 0.030
  - `tcp_offset_val`: 0.150
  - 定义文件: 章节 5.2 的 `create_robot_model.m` 脚本 (与UR5参数一致)
- MATLAB `rigidBodyTree` 关节限制 (UR5):
  - `shoulder_pan_joint`: [-2*pi, 2*pi]
  - `shoulder_lift_joint`: [-pi/2, pi/2]
  - `elbow_joint`: [-0.75*pi, 0.75*pi]
  - `wrist_1_joint`: [-2*pi, 2*pi]
  - `wrist_2_joint`: [-2*pi, 2*pi]
  - `wrist_3_joint`: [-2*pi, 2*pi]
  - 定义文件: 章节 5.2 的 `create_robot_model.m` 脚本 (在 `joint_limits_table` 中, 与UR5参数一致)

**3. 环境物体参数 (Gazebo 世界)**

- 物理引擎参数 (示例):
  - `max_step_size`: 0.001 s
  - `real_time_factor`: 1
  - `real_time_update_rate`: 1000 Hz
  - `gravity`: 0 0 -9.81 m/s²
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<physics>` 标签内)
- 桌子 (`table`) 参数 (示例):
  - `static`: true (固定)
  - `pose`: x=0.6, y=0, z=0 (米)
  - `size`: 1.25 x 1.25 x 0.05 (米)
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<model name="table">` 内)
- 静态障碍物 - 立方体 (`obstacle_box`) 参数 (示例):
  - `static`: true
  - `pose`: x=0.6, y=0.25, z=0.175 (米)
  - `size`: 0.125 x 0.125 x 0.25 (米)
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<model name="obstacle_box">` 内)
- 静态障碍物 - 圆柱体 (`obstacle_cylinder`) 参数 (示例):
  - `static`: true
  - `pose`: x=0.8, y=-0.25, z=0.175 (米)
  - `radius`: 0.0625 m
  - `length`: 0.3125 m
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<model name="obstacle_cylinder">` 内)
- 起点标记 (`start_marker`) 参数 (示例):
  - `static`: true
  - `pose`: x=0.3, y=0.4, z=0.075 (米)
  - `radius`: 0.025 m
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<model name="start_marker">` 内)
- 终点标记 (`goal_marker`) 参数 (示例):
  - `static`: true
  - `pose`: x=0.9, y=0.4, z=0.075 (米)
  - `radius`: 0.025 m
  - 定义文件: 章节 4.5 的 `~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world` 文件 (在 `<model name="goal_marker">` 内)

**4. 脚本与算法参数 (示例)**

- 深度相机 (`camera`) 参数 (示例):
  - `update_rate`: 20.0 Hz
  - `horizontal_fov`: 1.047 rad (约60度)
  - `image width/height`: 640x480
  - `clip near/far`: 0.05 m / 3.0 m
  - `pointCloudCutoff / CutoffMax`: 0.05 m / 3.0 m
  - 定义文件: 章节 4.3 的 `~/catkin_ws/src/arm_obstacle_avoidance/urdf/custom_camera.gazebo.xacro` 文件 (在 `<sensor type="depth">` 插件内, 用于定义深度相机，并通过 `custom_arm.urdf.xacro` 引入)
- 点云处理 (`process_point_cloud.m`) 参数 (示例):
  - 降采样网格大小 (`gridStep`): 0.025 m
  - 地面移除阈值 (`zGroundThreshold`): 0.025 m
  - 聚类最小距离 (`minClusterDistance`): 0.06 m
  - 聚类最小/最大点数: 10 / 25000
  - 定义文件: 章节 5.3 的 `process_point_cloud.m` 脚本内部
- 路径规划 (`plan_path.m`) 参数 (示例):
  - RRT `MaxConnectionDistance`: 0.5 rad
  - RRT `MaxIterations`: 5000
  - 定义文件: 章节 5.4 的 `plan_path.m` 脚本内部
- 主动避障 (`active_obstacle_avoidance.m`) 参数 (示例):
  - 环境监测频率 (`monitoringRate`): 5 Hz
  - 障碍物变化检测阈值 (`obstacleChangeThreshold`): 0.125 m
  - 定义文件: 章节 5.8 的 `active_obstacle_avoidance.m` 脚本内部
- MATLAB 目标位姿 (`arm_obstacle_avoidance.m`, `active_obstacle_avoidance.m`) 参数 (示例):
  - `goalPosition`: [0.7, 0.3, 0.2] (米)
  - 定义文件: 章节 5.7 的 `arm_obstacle_avoidance.m` 和 章节 5.8 的 `active_obstacle_avoidance.m` 脚本内部
- MATLAB 逆运动学 (`inverseKinematics`) 权重 (示例):
  - `weights`: [0.25 0.25 0.25 1 1 1]
  - 定义文件: 章节 5.7 的 `arm_obstacle_avoidance.m` 和 章节 5.8 的 `active_obstacle_avoidance.m` 脚本内部





## 1. 引言

本项目旨在为用户提供一份详尽的实践操作指南，以实现一个基于主动避障的自定义机械臂点到点运动规划系统。该系统将利用机器人操作系统（ROS）、MATLAB及其机器人工具箱（Robotics System Toolbox）以及Gazebo仿真环境。机械臂在接收到主机MATLAB算法返回的路径信息后，其夹爪将从起点沿路径移动。若途中遇到新的障碍物导致无法继续沿原路径移动，机械臂将重新扫描环境信息，并将信息发送给MATLAB以规划新的路径，如此反复，直至夹爪到达预设终点。

本指南将详细阐述环境配置、自定义机械臂的建模、Gazebo仿真环境的搭建、MATLAB与ROS的通信机制、核心算法（正逆运动学、轨迹规划、路径规划）的实现，以及最终的主动避障运动规划流程。本指南假设用户已在Windows 11操作系统上安装了MATLAB及机器人工具箱，并在VMware虚拟机中安装了Ubuntu 20.04和ROS Noetic。

## 2. 环境设置与先决条件

成功实现本项目依赖于正确配置的软硬件环境及通信链路。本节将详细介绍操作系统、虚拟机、MATLAB、ROS Noetic以及它们之间的网络通信设置。

### 2.1. 操作系统与虚拟机环境

用户需确保Windows 11主机已成功安装MATLAB及Robotics System Toolbox。虚拟机环境为VMware Workstation或VMware Player中运行的Ubuntu 20.04，并已安装ROS Noetic桌面完整版（Desktop-Full Install）。

### 2.2. MATLAB与ROS (Ubuntu VM) 网络通信配置

MATLAB（运行于Windows 11主机）与ROS（运行于Ubuntu虚拟机）之间的稳定通信是本项目的核心。推荐采用基于IP地址的标准ROS网络配置。

2.2.1. VMware网络适配器设置

为确保虚拟机能够作为独立节点接入局域网并拥有自己的IP地址，从而便于主机访问，VMware虚拟机的网络适配器应设置为“桥接模式 (Bridged Adapter)”。

配置步骤如下：

1. 关闭Ubuntu虚拟机。
2. 打开VMware，选择对应的Ubuntu虚拟机。
3. 进入虚拟机设置，导航至“网络适配器”选项。
4. 在“网络连接”部分，选择“桥接模式：直接连接到物理网络”。
5. （可选但推荐）在“桥接到：”下拉菜单中，明确选择主机用于连接网络的物理网卡（如有线网卡或无线网卡）。
6. 确保勾选“启动时连接”。
7. 保存设置。 通过桥接模式，虚拟机将从您本地网络的DHCP服务器获取一个IP地址，使其在网络上表现得像一台独立的物理设备，这对于ROS节点间的发现和通信至关重要 1。

2.2.2. ROS环境变量配置 (Ubuntu VM)

在Ubuntu虚拟机中，需要正确设置以下ROS环境变量，以确保ROS节点能够被网络中的其他节点（包括MATLAB中的ROS节点）发现和访问：

1. 启动Ubuntu虚拟机，打开终端。
2. 获取虚拟机的IP地址。使用命令 ip addr show 或 ifconfig，记录下与桥接网卡（通常为 eth0 或 ensXX）关联的IP地址。此IP地址后续将用于配置MATLAB。
3. 设置 ROS_MASTER_URI：此变量告知ROS节点ROS Master（核心管理器）的位置。由于ROS Master通常运行在虚拟机自身，可以设置为：

 Bash

```bash
export ROS_MASTER_URI=http://localhost:11311
```
 为使其永久生效，可将此命令添加到 ~/.bashrc 文件中，并执行 source ~/.bashrc。

4. 设置 ROS_IP 或 ROS_HOSTNAME：此变量告知其他ROS节点当前ROS节点（在虚拟机上运行的节点）的可访问IP地址。应将其设置为步骤2中获取到的虚拟机IP地址：

 Bash
 ```bash
 export ROS_IP=<your_ubuntu_vm_ip_address>
 ```
 同样，为使其永久生效，可添加到 ~/.bashrc 并source。

5. 启动ROS Master：

 ```Bash
 roscore
 ```

这些环境变量的正确配置是ROS网络通信的基础，确保了MATLAB能够找到并连接到ROS Master，同时也让虚拟机中的ROS节点能够被MATLAB发现 。

2.2.3. MATLAB中初始化ROS网络 (Windows 11 Host)

在Windows 11主机的MATLAB环境中，使用 rosinit 命令连接到运行在Ubuntu虚拟机中的ROS Master。

1. 获取Windows 11主机的IP地址。在命令提示符中使用 ipconfig，记录下与虚拟机处于同一网络的网卡IP地址。
2. 在MATLAB命令行中执行：

 Matlab

```matlab
rosinit('http://192.168.110.23:11311', 'NodeHost', '192.168.110.148')
```


将 <your_ubuntu_vm_ip_address> 替换为虚拟机IP地址，将 <your_windows_11_host_ip_address> 替换为主机IP地址。NodeHost 参数指定了MATLAB创建的ROS节点所广播的地址，确保虚拟机中的节点可以回连到MATLAB 。

2.2.4. 防火墙配置 (Windows 11 Host)

Windows防火墙可能会阻止MATLAB与虚拟机ROS网络之间的通信。需要配置入站和出站规则以允许ROS相关的端口通信。

1. 打开“Windows Defender 防火墙” -> “高级设置”。
2. 为“入站规则”和“出站规则”分别创建新规则。
3. 选择“端口”类型。
4. 选择“TCP”，并在“特定本地端口”中输入ROS常用端口，如 11311 (ROS Master), 以及其他ROS节点间通信可能使用的随机端口。为简化配置，可以考虑允许MATLAB应用程序通过防火墙，或在测试阶段暂时禁用特定网络配置文件（如“专用”）的防火墙。ROS节点会任意分配端口号，因此防火墙配置不当可能导致节点间通信受阻 。

**2.2.5. 使用 rosbridge_suite 进行通信 (备选方案)**

如果直接的ROS网络配置遇到困难，或者需要更灵活的跨平台通信方式，可以考虑使用 rosbridge_suite。rosbridge_suite 提供了一个JSON API，通过WebSocket将ROS的功能暴露给非ROS程序（如MATLAB）。

●   **Ubuntu** **端安装与启动**：
 ```Bash
 sudo apt-get install ros-noetic-rosbridge-server
 roslaunch rosbridge_server rosbridge_websocket.launch
 ```
 这会启动一个WebSocket服务器，默认监听 9090 端口 。

●   **MATLAB** **端客户端**：MATLAB本身不直接内置WebSocket客户端，但可以通过以下方式实现：

○   使用MATLAB的Java接口调用Java WebSocket库。例如，ros_websocket.m 文件提供了一个基于Java的MATLAB WebSocket客户端实现，用于连接rosbridge 。安装和使用此类库需要配置MATLAB的Java Classpath。

○   通过MATLAB的Python接口调用Python的WebSocket库。

○   一旦连接建立，MATLAB脚本可以发送JSON格式的命令来发布/订阅ROS话题、调用服务等。例如，订阅话题的JSON消息结构为：{"op": "subscribe", "topic": "/topic_name", "type": "message_type"}。

选择合适的通信方式并确保其稳定运行，是后续所有开发工作的前提。对于本项目，直接的ROS网络配置因其原生性和效率通常是首选，而 rosbridge 作为一个强大的备选方案，在特定场景下能提供便利。

## 3. 自定义机械臂定义

为了实现特定任务，用户需要定义一个自定义的机械臂模型。此模型将在MATLAB中用于运动学计算和轨迹规划，并在Gazebo中进行仿真和可视化。这要求我们为同一个机械臂创建两种不同但运动学上一致的表示形式。

### 3.1. MATLAB: 使用 D-H参数与rigidBodyTree 定义机械臂的运动学特性

MATLAB的Robotics System Toolbox使用 `rigidBodyTree` 对象来表示机械臂的运动学模型。通过Denavit-Hartenberg (D-H)参数法，可以精确定义各连杆之间的几何关系，这是后续进行运动学分析、轨迹规划的基础。

#### 3.1.1. Denavit-Hartenberg (D-H) 参数

Denavit-Hartenberg (D-H)参数是一种标准方法，用四个参数 (ai,αi,di,θi) 来描述机器人中相邻两个连杆坐标系之间的关系 。

●   ai：连杆长度 (link length)

●   αi：连杆扭转角 (link twist)

●   di：连杆偏移 (link offset)

●   θi：关节角 (joint angle)

对于自定义机械臂，首先需要确定其准确的D-H参数表。例如，一个六自由度机械臂的D-H参数可能如下表所示（具体数值需根据实际机械臂结构确定）：

| 关节i | ai（m） | ai（rad） | di（m） | θi (rad) |
| ----- | ------- | --------- | ------- | -------- |
| 1     | 0       | π/2       | d1      | θ1∗      |
| 2     | a2      | 0         | 0       | θ2∗      |
| 3     | a3      | 0         | 0       | θ3∗      |
| 4     | 0       | π/2       | d4      | θ4∗      |
| 5     | 0       | -π/2      | d5      | θ5∗      |
| 6     | 0       | 0         | d6      | θ6∗      |

*注：θi∗ 表示关节变量。*

这些参数将直接用于在MATLAB中构建 `rigidBodyTree` 对象。

#### 3.1.2. 在MATLAB中构建 rigidBodyTree 对象

在MATLAB中，可以使用 `rigidBodyTree` 对象、`rigidBody` 对象和 `rigidBodyJoint` 对象，结合D-H参数来构建机械臂的运动学模型。基本步骤包括：

1. 初始化一个 `rigidBodyTree` 对象。
2. 对于机械臂的每个连杆：
   - 创建一个 `rigidBody` 对象来代表该连杆。
   - 创建一个 `rigidBodyJoint` 对象来代表连接到该连杆的关节（通常是转动关节 'revolute' 或移动关节 'prismatic'）。
   - 使用 `setFixedTransform` 方法，并指定D-H参数，来定义该关节相对于其父连杆坐标系的固定变换。
   - 将关节赋给连杆对象。
   - 使用 `addBody` 方法将该连杆及其关节添加到 `rigidBodyTree` 模型中，并指定其父连杆。
3. （可选）添加末端执行器（工具）连杆，通常通过一个固定关节（'fixed'）连接到最后一个活动连杆。
4. （可选）为每个关节设置其运动范围（PositionLimits）。

关于如何在MATLAB中利用D-H参数一步步创建自定义机械臂的 `rigidBodyTree` 模型的详细代码实现、包括连杆与关节的命名、以及添加末端工具和设置关节限位的完整示例，请参阅本指南的 **5.2节 “创建机械臂模型”**。该章节提供了可以直接运行的 `create_robot_model` 函数。

### **3.2. Gazebo: 使用URDF/SDF对机械臂进行建模**

在MATLAB中使用 rigidBodyTree 和D-H参数定义了机械臂的运动学模型后（如3.1节所述），下一步是在Gazebo仿真环境中创建该机械臂的数字孪生。Gazebo使用URDF (Unified Robot Description Format) 或SDF (Simulation Description Format) 文件来描述机器人模型。URDF专注于描述单个机器人的运动学和动力学特性、碰撞模型和视觉模型，而SDF则是一个更全面的格式，可以描述整个仿真世界。对于像UR5这样的复杂机械臂，通常使用URDF，并通过Xacro (XML Macros) 语言进行模块化和参数化定义，最终生成完整的URDF文件供Gazebo使用。

本节将详细解释如何为Gazebo定义我们的自定义机械臂模型。我们的核心文件是 `custom_arm.urdf.xacro`，它通过Xacro宏集成了标准的UR5机械臂模型 (来自 `ur_description` 包)，并在此基础上添加了自定义的末端执行器接口和深度相机。深度相机的Gazebo插件和传感器定义则分离在 `custom_camera.gazebo.xacro` 文件中，并由主 `custom_arm.urdf.xacro` 文件引入。这种模块化的方法使得模型更易于管理和扩展。

#### **3.2.1. 自定义机械臂 (`custom_arm.urdf.xacro`) 结构与相机集成示例**

本节将展示 `custom_arm.urdf.xacro` 如何集成标准UR5模型并添加自定义组件（如相机和末端执行器接口）的一个概念性示例。实际的 `custom_arm.urdf.xacro` 文件内容会更详细，并依赖于具体的UR5宏参数和自定义部件的设计。

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/xacro" name="custom_ur5_arm_with_camera">

  <!-- 1. 包含标准的UR5机械臂宏 -->
  <!-- 确保 joint_limited, safety_limits 等参数根据需求传递 -->
  <xacro:include filename="$(find ur_description)/urdf/ur5.urdf.xacro" />

  <!-- 2. 实例化UR5机械臂，可以指定前缀 -->
  <xacro:property name="robot_prefix" value="" /> <!-- 根据需要设置前缀 -->
  <xacro:ur5_robot prefix="${robot_prefix}" joint_limited="true"/>

  <!-- 3. 定义自定义连杆 (例如：相机安装板、夹爪基座) -->
  <!-- 示例：相机安装板 -->
  <link name="${prefix}camera_mount_link">
    <visual>
      <geometry><box size="0.05 0.05 0.01"/></geometry>
      <material name="grey"><color rgba="0.5 0.5 0.5 1"/></material>
    </visual>
    <collision><geometry><box size="0.05 0.05 0.01"/></geometry></collision>
    <inertial>
      <mass value="0.05"/>
      <inertia ixx="1e-4" iyy="1e-4" izz="1e-4" ixy="0" ixz="0" iyz="0"/>
    </inertial>
  </link>

  <!-- 4. 定义连接自定义连杆到UR5末端连杆 (wrist_3_link) 的关节 -->
  <joint name="${prefix}camera_mount_joint" type="fixed">
    <parent link="${prefix}wrist_3_link"/>
    <child link="${prefix}camera_mount_link"/>
    <origin xyz="0 0 0.01" rpy="0 0 0"/> <!-- 相对于 wrist_3_link 的位姿 -->
  </joint>

  <!-- 5. 包含自定义相机的Gazebo描述文件 -->
  <!-- custom_camera.gazebo.xacro 文件将定义相机连杆、关节和传感器插件 -->
  <!-- 假设相机连杆名为 '${prefix}camera_link'，它将通过 '${prefix}camera_joint' 连接到 '${prefix}camera_mount_link' -->
  <xacro:include filename="$(find arm_obstacle_avoidance)/urdf/custom_camera.gazebo.xacro" />
  <xacro:custom_camera_definition prefix="${prefix}" parent_link="${prefix}camera_mount_link" />

  <!-- (可选) 6. 定义其他自定义末端执行器连杆和关节 -->
  <!-- 例如，一个简单的夹爪基座 -->
  <link name="${prefix}gripper_base_link">
    <visual>
      <geometry><cylinder radius="0.02" length="0.03"/></geometry>
      <material name="darkgrey"><color rgba="0.3 0.3 0.3 1"/></material>
    </visual>
    <collision><geometry><cylinder radius="0.02" length="0.03"/></geometry></collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="1e-3" iyy="1e-3" izz="5e-4" ixy="0" ixz="0" iyz="0"/>
    </inertial>
  </link>

  <joint name="${prefix}gripper_base_joint" type="fixed">
    <parent link="${prefix}wrist_3_link"/> <!-- 或者连接到其他自定义连杆 -->
    <child link="${prefix}gripper_base_link"/>
    <origin xyz="0 0 0.05" rpy="0 ${pi/2} 0"/> <!-- 示例位姿 -->
  </joint>

  <!-- 注意: 上述 custom_camera_definition 宏需要在 custom_camera.gazebo.xacro 中定义， -->
  <!-- 它会负责创建相机连杆 (camera_link) 并将其连接到指定的 parent_link (camera_mount_link)。 -->
  <!-- 实际的夹爪连杆和关节也应在此处或单独的xacro文件中定义并包含。 -->

</robot>

shoulder_lift_lower_limit:=${-pi}
shoulder_lift_upper_limit:=${pi}
    elbow_joint_lower_limit:=${-pi}    elbow_joint_upper_limit:=${pi}
    wrist_1_lower_limit:=${-pi}    wrist_1_upper_limit:=${pi}
    wrist_2_lower_limit:=${-pi}    wrist_2_upper_limit:=${pi}
    wrist_3_lower_limit:=${-pi}    wrist_3_upper_limit:=${pi}
    transmission_hw_interface:=hardware_interface/PositionJointInterface
    safety_limits:=false safety_pos_margin:=0.15
    safety_k_position:=20">
    
    <!-- Inertia parameters -->
    <xacro:property name="base_mass" value="4.0" />  <!-- This mass might be incorrect -->
    <xacro:property name="shoulder_mass" value="3.7000" />
    <xacro:property name="upper_arm_mass" value="8.3930" />
    <xacro:property name="forearm_mass" value="2.2750" />
    <xacro:property name="wrist_1_mass" value="1.2190" />
    <xacro:property name="wrist_2_mass" value="1.2190" />
    <xacro:property name="wrist_3_mass" value="0.1879" />
    
    <xacro:property name="shoulder_cog" value="0.0 0.00193 -0.02561" />
    <xacro:property name="upper_arm_cog" value="0.0 -0.024201 0.2125" />
    <xacro:property name="forearm_cog" value="0.0 0.0265 0.11993" />
    <xacro:property name="wrist_1_cog" value="0.0 0.110949 0.01634" />
    <xacro:property name="wrist_2_cog" value="0.0 0.0018 0.11099" />
    <xacro:property name="wrist_3_cog" value="0.0 0.001159 0.0" />
    
    <!-- Kinematic model -->
    <!-- Properties from urcontrol.conf -->
    <!--
      DH for UR5:
      a = [0.00000, -0.42500, -0.39225,  0.00000,  0.00000,  0.0000]
      d = [0.089159,  0.00000,  0.00000,  0.10915,  0.09465,  0.0823]
      alpha = [ 1.570796327, 0, 0, 1.570796327, -1.570796327, 0 ]
      q_home_offset = [0, -1.570796327, 0, -1.570796327, 0, 0]
      joint_direction = [-1, -1, 1, 1, 1, 1]
      mass = [3.7000, 8.3930, 2.2750, 1.2190, 1.2190, 0.1879]
      center_of_mass = [ [0, -0.02561, 0.00193], [0.2125, 0, 0.11336], [0.11993, 0.0, 0.0265], [0, -0.0018, 0.01634], [0, 0.0018,0.01634], [0, 0, -0.001159] ]
    -->
    <xacro:property name="d1" value="0.089159" />
    <xacro:property name="a2" value="-0.42500" />
    <xacro:property name="a3" value="-0.39225" />
    <xacro:property name="d4" value="0.10915" />
    <xacro:property name="d5" value="0.09465" />
    <xacro:property name="d6" value="0.0823" />
    
    <!-- Arbitrary offsets for shoulder/elbow joints -->
    <xacro:property name="shoulder_offset" value="0.13585" />  <!-- measured from model -->
    <xacro:property name="elbow_offset" value="-0.1197" /> <!-- measured from model -->
    
    <!-- link lengths used in model -->
    <xacro:property name="shoulder_height" value="${d1}" />
    <xacro:property name="upper_arm_length" value="${-a2}" />
    <xacro:property name="forearm_length" value="${-a3}" />
    <xacro:property name="wrist_1_length" value="${d4 - elbow_offset - shoulder_offset}" />
    <xacro:property name="wrist_2_length" value="${d5}" />
    <xacro:property name="wrist_3_length" value="${d6}" />
    <!--property name="shoulder_height" value="0.089159" /-->
    <!--property name="shoulder_offset" value="0.13585" /-->  <!-- shoulder_offset - elbow_offset + wrist_1_length = 0.10915 -->
    <!--property name="upper_arm_length" value="0.42500" /-->
    <!--property name="elbow_offset" value="0.1197" /-->       <!-- CAD measured -->
    <!--property name="forearm_length" value="0.39225" /-->
    <!--property name="wrist_1_length" value="0.093" /-->     <!-- CAD measured -->
    <!--property name="wrist_2_length" value="0.09465" /-->   <!-- In CAD this distance is 0.930, but in the spec it is 0.09465 -->
    <!--property name="wrist_3_length" value="0.0823" /-->
    
    <xacro:property name="shoulder_radius" value="0.060" />   <!-- manually measured -->
    <xacro:property name="upper_arm_radius" value="0.054" />  <!-- manually measured -->
    <xacro:property name="elbow_radius" value="0.060" />      <!-- manually measured -->
    <xacro:property name="forearm_radius" value="0.040" />    <!-- manually measured -->
    <xacro:property name="wrist_radius" value="0.045" />      <!-- manually measured -->


    <link name="${prefix}base_link" >
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/base.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/base.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="0.05" mass="${base_mass}">
        <origin xyz="0.0 0.0 0.0" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}shoulder_pan_joint" type="revolute">
      <parent link="${prefix}base_link" />
      <child link = "${prefix}shoulder_link" />
      <origin xyz="0.0 0.0 ${shoulder_height}" rpy="0.0 0.0 0.0" />
      <axis xyz="0 0 1" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${shoulder_pan_lower_limit}" upper="${shoulder_pan_upper_limit}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${shoulder_pan_lower_limit + safety_pos_margin}" soft_upper_limit="${shoulder_pan_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}shoulder_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/shoulder.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/shoulder.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="0.15" mass="${shoulder_mass}">
        <origin xyz="0.0 0.0 0.0" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}shoulder_lift_joint" type="revolute">
      <parent link="${prefix}shoulder_link" />
      <child link = "${prefix}upper_arm_link" />
      <origin xyz="0.0 ${shoulder_offset} 0.0" rpy="0.0 ${pi / 2.0} 0.0" />
      <axis xyz="0 1 0" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${shoulder_lift_lower_limit}" upper="${shoulder_lift_upper_limit}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${shoulder_lift_lower_limit + safety_pos_margin}" soft_upper_limit="${shoulder_lift_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}upper_arm_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/upperarm.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/upperarm.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="0.56" mass="${upper_arm_mass}">
        <origin xyz="0.0 0.0 0.28" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}elbow_joint" type="revolute">
      <parent link="${prefix}upper_arm_link" />
      <child link = "${prefix}forearm_link" />
      <origin xyz="0.0 ${elbow_offset} ${upper_arm_length}" rpy="0.0 0.0 0.0" />
      <axis xyz="0 1 0" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-pi}" upper="${pi}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${elbow_joint_lower_limit}" upper="${elbow_joint_upper_limit}" effort="150.0" velocity="3.15"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${elbow_joint_lower_limit + safety_pos_margin}" soft_upper_limit="${elbow_joint_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}forearm_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/forearm.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/forearm.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="${-a3}" mass="${forearm_mass}">
        <origin xyz="0.0 0.0 ${-a3/2}" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}wrist_1_joint" type="revolute">
      <parent link="${prefix}forearm_link" />
      <child link = "${prefix}wrist_1_link" />
      <origin xyz="0.0 0.0 ${forearm_length}" rpy="0.0 ${pi / 2.0} 0.0" />
      <axis xyz="0 1 0" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${wrist_1_lower_limit}" upper="${wrist_1_upper_limit}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${wrist_1_lower_limit + safety_pos_margin}" soft_upper_limit="${wrist_1_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}wrist_1_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/wrist1.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/wrist1.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="0.12" mass="${wrist_1_mass}">
        <origin xyz="0.0 ${wrist_1_length} 0.0" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}wrist_2_joint" type="revolute">
      <parent link="${prefix}wrist_1_link" />
      <child link = "${prefix}wrist_2_link" />
      <origin xyz="0.0 ${wrist_1_length} 0.0" rpy="0.0 0.0 0.0" />
      <axis xyz="0 0 1" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${wrist_2_lower_limit}" upper="${wrist_2_upper_limit}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${wrist_2_lower_limit + safety_pos_margin}" soft_upper_limit="${wrist_2_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}wrist_2_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/wrist2.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/wrist2.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.06" length="0.12" mass="${wrist_2_mass}">
        <origin xyz="0.0 0.0 ${wrist_2_length}" rpy="0 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}wrist_3_joint" type="revolute">
      <parent link="${prefix}wrist_2_link" />
      <child link = "${prefix}wrist_3_link" />
      <origin xyz="0.0 0.0 ${wrist_2_length}" rpy="0.0 0.0 0.0" />
      <axis xyz="0 1 0" />
      <xacro:unless value="${joint_limited}">
        <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${-2.0 * pi + safety_pos_margin}" soft_upper_limit="${2.0 * pi - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:unless>
      <xacro:if value="${joint_limited}">
        <limit lower="${wrist_3_lower_limit}" upper="${wrist_3_upper_limit}" effort="28.0" velocity="3.2"/>
        <xacro:if value="${safety_limits}">
          <safety_controller soft_lower_limit="${wrist_3_lower_limit + safety_pos_margin}" soft_upper_limit="${wrist_3_upper_limit - safety_pos_margin}" k_position="${safety_k_position}" k_velocity="0.0"/>
        </xacro:if>
      </xacro:if>
      <dynamics damping="0.0" friction="0.0"/>
    </joint>
    
    <link name="${prefix}wrist_3_link">
      <visual>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/visual/wrist3.dae" />
        </geometry>
        <material name="LightGrey">
          <color rgba="0.7 0.7 0.7 1.0"/>
        </material>
      </visual>
      <collision>
        <geometry>
          <mesh filename="package://ur_description/meshes/ur5/collision/wrist3.stl" />
        </geometry>
      </collision>
      <xacro:cylinder_inertial radius="0.0375" length="0.0345" mass="${wrist_3_mass}">
        <origin xyz="0.0 ${wrist_3_length - 0.0345/2} 0.0" rpy="${pi/2} 0 0" />
      </xacro:cylinder_inertial>
    </link>
    
    <joint name="${prefix}ee_fixed_joint" type="fixed">
      <parent link="${prefix}wrist_3_link" />
      <child link = "${prefix}ee_link" />
      <origin xyz="0.0 ${wrist_3_length} 0.0" rpy="0.0 0.0 ${pi/2.0}" />
    </joint>
    
    <link name="${prefix}ee_link">
      <collision>
        <geometry>
          <box size="0.01 0.01 0.01"/>
        </geometry>
        <origin rpy="0 0 0" xyz="-0.01 0 0"/>
      </collision>
    </link>
    
    <xacro:ur_arm_transmission prefix="${prefix}" hw_interface="${transmission_hw_interface}" />
    <xacro:ur_arm_gazebo prefix="${prefix}" />
    
    <!-- ROS base_link to UR 'Base' Coordinates transform -->
    <link name="${prefix}base"/>
    <joint name="${prefix}base_link-base_fixed_joint" type="fixed">
      <!-- NOTE: this rotation is only needed as long as base_link itself is
                 not corrected wrt the real robot (ie: rotated over 180
                 degrees)
      -->
      <origin xyz="0 0 0" rpy="0 0 ${-pi}"/>
      <parent link="${prefix}base_link"/>
      <child link="${prefix}base"/>
    </joint>
    
    <!-- Frame coincident with all-zeros TCP on UR controller -->
    <link name="${prefix}tool0"/>
    <joint name="${prefix}wrist_3_link-tool0_fixed_joint" type="fixed">
      <origin xyz="0 ${wrist_3_length} 0" rpy="${pi/-2.0} 0 0"/>
      <parent link="${prefix}wrist_3_link"/>
      <child link="${prefix}tool0"/>
    </joint>

  </xacro:macro>
</robot>
```

#### **3.2.2. 解析 ur5.urdf.xacro 文件**

Xacro (XML Macros) 是一种宏语言，它允许我们创建更简洁、模块化和可重用的URDF文件。上述文件就是用Xacro编写的。在被Gazebo或ROS其他工具使用之前，它会被 xacro 程序转换成一个标准的URDF文件。

##### **1. 整体结构与Xacro基础**

● <robot xmlns:xacro="http://wiki.ros.org/xacro">: 这是URDF/Xacro文件的根元素。xmlns:xacro 声明了Xacro命名空间，使得我们可以使用 <xacro:...> 标签。

● <xacro :include filename="..." />: 这个指令用于包含其他Xacro文件。

\* $(find ur_description)/urdf/ur.transmission.xacro: 包含了用于定义ros_control所需的<transmission>标签的宏。Transmission将执行器（如电机）与关节联系起来。

\* $(find ur_description)/urdf/ur.gazebo.xacro: 包含了Gazebo仿真相关的宏和插件定义，例如物理属性、传感器接口、gazebo_ros_control插件等。

##### **2. Xacro宏 (Macros)**

宏允许我们定义可重用的XML代码块。

● <xacro:macro name="cylinder_inertial" params="radius length mass *origin">:

这是一个工具宏，用于方便地计算和定义圆柱体形状连杆的惯性参数（质量、质心偏移、惯性张量）。

\* params: 定义了宏的参数，如 radius (半径), length (长度), mass (质量)。*origin 表示可以传入一个名为 origin 的XML块。

\* 内部使用这些参数计算惯性张量的各个分量。

● <xacro:macro name="ur5_robot" params="prefix joint_limited ...">:

这是定义整个UR5机器人模型的核心宏。

*params:

\* prefix: 一个字符串前缀，用于所有连杆和关节的名称，方便在同一个仿真环境中生成多个机器人而名称不冲突。

\* joint_limited: 布尔值，决定是否使用严格的关节限位。

\* shoulder_pan_lower_limit, shoulder_pan_upper_limit, 等: 各个关节的上下限位值（弧度）。

\* transmission_hw_interface: 为ros_control指定硬件接口类型。

\* safety_limits, safety_pos_margin, safety_k_position: 与安全控制器相关的参数。

##### **3. Xacro属性 (Properties)**

属性用于定义常量，可以在文件中的多处通过 ${propertyName} 的方式引用。

● 惯性参数:

```xml 
<xacro:property name="base_mass" value="4.0" /> <xacro:property name="shoulder_mass" value="3.7000" /> <xacro:property name="shoulder_cog" value="0.0 0.00193 -0.02561" />
```

这些属性定义了机器人各个连杆的质量和质心位置。

● 运动学参数 (D-H参数):

文件注释中列出了UR5的D-H参数，并基于这些参数定义了Xacro属性：

```xml 
<xacro:property name="d1" value="0.089159" /> <xacro:property name="a2" value="-0.42500" /> <xacro:property name="a3" value="-0.39225" /> <xacro:property name="d4" value="0.10915" /> <xacro:property name="d5" value="0.09465" /> <xacro:property name="d6" value="0.0823" />
```

这些D-H参数是机器人运动学定义的基石，必须与3.1节中MATLAB rigidBodyTree 模型使用的D-H参数严格一致。

● 连杆长度和偏移:

基于D-H参数和其他测量值，定义了用于模型构建的实际长度：

```xml 
<xacro:property name="shoulder_height" value="${d1}" /> <xacro:property name="upper_arm_length" value="${-a2}" /> <xacro:property name="forearm_length" value="${-a3}" />
```

这些属性将在定义关节的 <origin> 标签时使用，以确定连杆间的相对位置。

##### **4. 连杆 (Links)**

每个 <link> 元素定义了机器人的一个刚性部件。例如，base_link (基座) 的定义：

```xml
<link name="${prefix}base_link" >  <visual>    <geometry>      <mesh filename="package://ur_description/meshes/ur5/visual/base.dae" />    </geometry>    <material name="LightGrey">      <color rgba="0.7 0.7 0.7 1.0"/>    </material>  </visual>  <collision>    <geometry>      <mesh filename="package://ur_description/meshes/ur5/collision/base.stl" />    </geometry>  </collision>  <xacro:cylinder_inertial radius="0.06" length="0.05" mass="${base_mass}">    <origin xyz="0.0 0.0 0.0" rpy="0 0 0" />  </xacro:cylinder_inertial></link>
```

● <visual>: 定义连杆在RViz或Gazebo中的外观。

\* <geometry>: 可以是简单形状（<box>, <cylinder>, <sphere>）或外部3D网格文件（<mesh filename="..." />）。这里使用了DAE (Digital Asset Exchange) 文件。

\* <material>: 定义颜色和纹理。

● <collision>: 定义连杆的碰撞模型，用于物理引擎的碰撞检测。

\* 其结构与 <visual> 类似，但通常使用简化的几何形状或专门的碰撞网格（如STL文件）以提高性能。准确的碰撞模型对于本项目的主动避障功能至关重要。

● <inertial>: 定义连杆的惯性属性。

\* <mass value="..." />: 质量。

\* <origin xyz="..." rpy="..." />: 质心(CoM)相对于连杆坐标系原点的位置和姿态。

\* <inertia ixx="..." ... />: 惯性张量。

这里通过调用之前定义的 cylinder_inertial 宏来设置惯性参数。

其他连杆如 ${prefix}shoulder_link, ${prefix}upper_arm_link 等也遵循类似的结构。

##### **5. 关节 (Joints)**

每个 <joint> 元素定义了两个连杆之间的连接方式和相对运动。例如，shoulder_pan_joint (肩部旋转关节) 的定义：

```xml
<joint name="${prefix}shoulder_pan_joint" type="revolute">  <parent link="${prefix}base_link" />  <child link = "${prefix}shoulder_link" />  <origin xyz="0.0 0.0 ${shoulder_height}" rpy="0.0 0.0 0.0" />  <axis xyz="0 0 1" />  <xacro:unless value="${joint_limited}">    <limit lower="${-2.0 * pi}" upper="${2.0 * pi}" effort="150.0" velocity="3.15"/>    </xacro:unless>  <xacro:if value="${joint_limited}">    <limit lower="${shoulder_pan_lower_limit}" upper="${shoulder_pan_upper_limit}" effort="150.0" velocity="3.15"/>    </xacro:if>  <dynamics damping="0.0" friction="0.0"/></joint>
```

● type="revolute": 表示这是一个旋转关节。其他类型有 prismatic, fixed, continuous 等。

● <parent link="..." /> 和 <child link="..." />: 定义了父连杆和子连杆。

● <origin xyz="..." rpy="..." />: 定义了子连杆坐标系原点相对于父连杆坐标系原点的位置和姿态变换。这是实现D-H参数定义的关键之处。

\* 对于 shoulder_pan_joint，xyz="0.0 0.0 ${shoulder_height}" 表示 shoulder_link 的原点沿 base_link 的Z轴向上平移 ${shoulder_height} (即D-H参数 d1) 的距离。

\* 对于 shoulder_lift_joint，<origin xyz="0.0 ${shoulder_offset} 0.0" rpy="0.0 ${pi / 2.0} 0.0" />。这里的 rpy 表示绕Y轴旋转90度，这对应D-H参数中的 alpha。xyz 中的 ${shoulder_offset} 是模型特定的偏移。

\* 对于 elbow_joint，<origin xyz="0.0 ${elbow_offset} ${upper_arm_length}" rpy="0.0 0.0 0.0" />。这里的 ${upper_arm_length} 对应D-H参数 a2 (的相反数)。

这些 <origin> 标签中的 xyz 和 rpy 值必须精确地反映D-H参数所描述的连杆间的几何关系。

● <axis xyz="..." />: 定义关节的旋转轴（对于旋转关节）或移动轴（对于移动关节），在关节坐标系（即子连杆坐标系）中定义。例如 0 0 1 表示绕Z轴旋转。

● <limit lower="..." upper="..." effort="..." velocity="..."/>: 定义关节的运动范围（最小/最大角度）、最大允许力/力矩和最大允许速度。

● <xacro:if value="${joint_limited}"> 和 <xacro:unless value="${joint_limited}">: Xacro的条件语句，用于根据 joint_limited 参数的值选择不同的关节限位配置。

● <dynamics damping="..." friction="..."/>: (可选) 定义关节的动力学属性，如阻尼和摩擦。

##### **6. 特殊连杆和关节 (工具端)**

● ${prefix}ee_link 和 ${prefix}ee_fixed_joint:

```xml
<joint name="${prefix}ee_fixed_joint" type="fixed">
    <parent link="${prefix}wrist_3_link" />
    <child link = "${prefix}ee_link" />
    <origin xyz="0.0 ${wrist_3_length} 0.0" rpy="0.0 0.0 ${pi/2.0}" />
</joint>
<link name="${prefix}ee_link">
    <collision> ... </collision>
</link>
```

定义了一个末端执行器连杆 (ee_link)，它通过一个固定关节 (fixed) 连接到 wrist_3_link。其 origin 定义了末端执行器坐标系相对于 wrist_3_link 的位姿。

● ${prefix}tool0 和 ${prefix}wrist_3_link-tool0_fixed_joint:

```xml
<link name="${prefix}tool0"/>
<joint name="${prefix}wrist_3_link-tool0_fixed_joint" type="fixed">
    <origin xyz="0 ${wrist_3_length} 0" rpy="${pi/-2.0} 0 0"/>
    <parent link="${prefix}wrist_3_link"/>
    <child link="${prefix}tool0"/>
</joint>
```

定义了一个名为 tool0 的连杆，它代表了机器人控制器上TCP（Tool Center Point，工具中心点）在全零配置时的位置。这个坐标系通常是进行任务空间规划时的参考。

##### **7. Transmission 和 Gazebo 集成调用**

在 ur5_robot 宏的末尾：
```xml
<xacro:ur_arm_transmission prefix="${prefix}" hw_interface="${transmission_hw_interface}" />
<xacro:ur_arm_gazebo prefix="${prefix}" />
```

● <xacro:ur_arm_transmission ... />: 调用了从 ur.transmission.xacro 文件中包含的宏，用于为每个非固定关节设置 <transmission> 标签。这些标签是 ros_control 框架所必需的，它将关节与硬件接口（在仿真中是仿真接口）连接起来，使得可以通过ROS话题控制关节运动。

● <xacro:ur_arm_gazebo ... />: 调用了从 ur.gazebo.xacro 文件中包含的宏。这个宏通常会：

\* 加载 gazebo_ros_control 插件，使得 ros_control 可以与Gazebo交互。

\* 为连杆设置Gazebo特定的物理属性（如摩擦系数、阻尼等）。

\* 可能包含传感器插件的定义（如果传感器是机器人固有的一部分）。

##### **8. 基座坐标系调整**
```xml
<link name="${prefix}base"/>
<joint name="${prefix}base_link-base_fixed_joint" type="fixed">
 <origin xyz="0 0 0" rpy="0 0 ${-pi}"/>
 <parent link="${prefix}base_link"/>
 <child link="${prefix}base"/>
</joint>
```

这里定义了一个额外的 base 连杆，并通过一个固定关节将其与 base_link 连接。origin 中的 rpy="0 0 ${-pi}" 表示绕Z轴旋转180度。这通常是为了使ROS中常用的 base_link 坐标系（通常X轴向前）与机器人制造商定义的物理基座坐标系（可能方向不同）对齐，或者是为了符合特定的ROS约定。

#### **3.2.3. 关键考量：运动学一致性与碰撞几何**

● 运动学一致性:

再次强调，ur5.urdf.xacro 文件中通过D-H参数（在 <xacro:property> 中定义）和关节 <origin> 标签所隐含的几何尺寸和变换，必须严格对应于3.1节中为MATLAB rigidBodyTree 模型所定义的D-H参数。例如，Xacro中的 ${d1} (shoulder_height)、${-a2} (upper_arm_length)、${-a3} (forearm_length)、${d4}、${d5}、${d6} 以及关节 <origin> 中的 xyz 和 rpy 值，共同构成了机器人的运动学链。任何不一致都会导致MATLAB中规划的轨迹在Gazebo中执行时产生错误或非预期的行为。

● 碰撞几何的重要性:

<collision> 标签内定义的几何形状（通常是 <mesh>）对物理引擎至关重要。Gazebo使用这些碰撞模型来检测机器人自身连杆之间（自碰撞）或机器人与环境中其他物体之间的碰撞。不准确或过于简化的碰撞模型可能导致碰撞漏检（机器人穿过障碍物）或误报（在没有实际接触时报告碰撞）。对于主动避障，精确且高效的碰撞模型是必不可শনের。ur5.urdf.xacro 为每个主要连杆都定义了相应的STL碰撞网格。

通过仔细定义Xacro文件，如上述 ur5.urdf.xacro.txt 所示，我们可以为Gazebo创建一个与MATLAB模型运动学一致、具备视觉和碰撞属性、并集成了ros_control和Gazebo特定插件的复杂机器人模型。这个模型是进行后续仿真、路径规划和避障算法测试的基础。

## 4. 搭建Gazebo仿真环境

本节将详细指导如何搭建一个完整的Gazebo仿真环境，包括创建ROS包、组织文件结构、安装必要的软件包、创建自定义世界文件、添加机械臂模型和障碍物，以及配置传感器以实现主动避障功能。

### 4.1 安装Gazebo和相关依赖
首先，确保已经安装了ROS Noetic和Gazebo。如果尚未安装，请按照以下步骤进行安装：
```bash
# 更新软件包列表
sudo apt update

# 安装ROS Noetic (如果尚未安装)
sudo apt install ros-noetic-desktop-full

# 安装Gazebo11 (ROS Noetic默认使用的版本)
sudo apt install gazebo11 ros-noetic-gazebo-ros-pkgs ros-noetic-gazebo-ros-control

# 安装机器人控制相关包
sudo apt install ros-noetic-joint-state-publisher ros-noetic-joint-state-publisher-gui
sudo apt install ros-noetic-controller-manager ros-noetic-effort-controllers
sudo apt install ros-noetic-position-controllers ros-noetic-joint-trajectory-controller

# 安装用于点云处理的包
sudo apt install ros-noetic-pcl-ros ros-noetic-pcl-conversions
```
安装完成后，验证Gazebo是否正常工作：
```bash
# 在终端中启动Gazebo
gazebo
```
如果Gazebo成功启动并显示一个空白的世界，则安装成功。

### 4.2 创建ROS包和目录结构
接下来，我们将创建一个名为arm_obstacle_avoidance的ROS包，并设置适当的目录结构：
```bash
# 创建工作空间（如果尚未创建）
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src

# 创建ROS包
catkin_create_pkg arm_obstacle_avoidance roscpp rospy std_msgs sensor_msgs geometry_msgs trajectory_msgs gazebo_ros gazebo_msgs tf2_ros pcl_ros

# 进入包目录
cd arm_obstacle_avoidance

# 创建必要的目录结构
mkdir -p config launch meshes urdf worlds scripts
```
这样，我们就创建了一个包含以下目录的ROS包：
config: 存放控制器配置文件
launch: 存放启动文件
meshes: 存放机械臂和环境的3D模型文件
urdf: 存放机械臂的URDF/Xacro文件
worlds: 存放Gazebo世界文件
scripts: 存放Python脚本

### 4.3 配置机械臂URDF文件
创建文件

~/catkin_ws/src/arm_obstacle_avoidance/urdf/custom_arm.urdf.xacro：

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://wiki.ros.org/xacro" name="custom_arm">

    <!-- Import UR5 robot xacro -->
    <xacro:include filename="$(find ur_description)/urdf/ur5.urdf.xacro" />

    <!-- Import custom camera gazebo plugin -->
    <xacro:include filename="$(find arm_obstacle_avoidance)/urdf/custom_camera.gazebo.xacro" />

    <!-- Constants for robot dimensions -->
    <xacro:property name="PI" value="3.1415926535897931" />

    <!-- Instantiate UR5 robot -->
    <xacro:ur5_robot prefix="" joint_limited="true"
      shoulder_pan_lower_limit="${-2*PI}" shoulder_pan_upper_limit="${2*PI}"
      shoulder_lift_lower_limit="${-PI/2}" shoulder_lift_upper_limit="${PI/2}"
      elbow_joint_lower_limit="${-0.75*PI}" elbow_joint_upper_limit="${0.75*PI}"
      wrist_1_lower_limit="${-2*PI}" wrist_1_upper_limit="${2*PI}"
      wrist_2_lower_limit="${-2*PI}" wrist_2_upper_limit="${2*PI}"
      wrist_3_lower_limit="${-2*PI}" wrist_3_upper_limit="${2*PI}"
    />

    <!-- Gripper and TCP offsets -->
    <xacro:property name="gripper_base_offset" value="0.030" />
    <xacro:property name="tcp_offset" value="0.150" />

    <!-- Gripper Base Link -->
    <link name="gripper_base_link">
        <visual>
            <geometry>
                <box size="0.05 0.05 0.05"/>
            </geometry>
            <origin xyz="0 0 0.025" rpy="0 0 0"/>
            <material name="Grey">
                <color rgba="0.5 0.5 0.5 1" />
            </material>
        </visual>
        <collision>
            <geometry>
                <box size="0.05 0.05 0.05"/>
            </geometry>
            <origin xyz="0 0 0.025" rpy="0 0 0"/>
        </collision>
        <inertial>
            <mass value="0.1" />
            <inertia ixx="0.00004166666666666667" ixy="0.0" ixz="0.0"
                     iyy="0.00004166666666666667" iyz="0.0"
                     izz="0.00004166666666666667" />
        </inertial>
    </link>

    <joint name="gripper_base_joint" type="fixed">
        <parent link="wrist_3_link"/>
        <child link="gripper_base_link"/>
        <origin xyz="0 0 ${gripper_base_offset}" rpy="0 0 0"/>
    </joint>

    <!-- Tool Center Point (TCP) -->
    <link name="tcp_link"/>
    <joint name="tcp_joint" type="fixed">
        <parent link="gripper_base_link"/>
        <child link="tcp_link"/>
        <origin xyz="0 0 ${tcp_offset}" rpy="0 0 0"/>
    </joint>

    <!-- Attach camera to a suitable link, e.g., wrist_3_link or a custom camera_link -->
    <xacro:custom_camera_gazebo prefix="camera_" parent_link="wrist_3_link">
        <origin xyz="0.05 0 0" rpy="0 ${PI/2} 0" />
    </xacro:custom_camera_gazebo>

</robot>
```

接下来，创建传动和Gazebo配置文件。	

Gazebo相关配置 (custom_arm.gazebo.xacro 和 custom_camera.gazebo.xacro)：

```bash
#创建custom_camera.gazebo.xacro文件
gedit custom_camera.gazebo.xacro
```

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://wiki.ros.org/xacro">

  <xacro:macro name="custom_camera_gazebo" params="prefix parent_link *origin">
    <link name="${prefix}camera_link">
      <visual>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <box size="0.02 0.05 0.05"/>
        </geometry>
        <material name="red">
            <color rgba="1.0 0.0 0.0 1.0"/>
        </material>
      </visual>
      <collision>
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <geometry>
          <box size="0.02 0.05 0.05"/>
        </geometry>
      </collision>
      <inertial>
        <mass value="0.01" />
        <origin xyz="0 0 0" rpy="0 0 0"/>
        <inertia ixx="1e-6" ixy="0" ixz="0" iyy="1e-6" iyz="0" izz="1e-6" />
      </inertial>
    </link>

    <joint name="${prefix}camera_joint" type="fixed">
      <xacro:insert_block name="origin" />
      <parent link="${parent_link}"/>
      <child link="${prefix}camera_link"/>
    </joint>

    <!-- Camera sensor -->
    <gazebo reference="${prefix}camera_link">
      <sensor type="depth" name="${prefix}depth_camera_sensor">
        <update_rate>20.0</update_rate>
        <camera name="head">
          <horizontal_fov>1.047</horizontal_fov> <!-- approx 60 degrees -->
          <image>
            <width>640</width>
            <height>480</height>
            <format>R8G8B8</format>
          </image>
          <clip>
            <near>0.05</near>
            <far>3.0</far>
          </clip>
        </camera>
        <plugin name="${prefix}depth_camera_controller" filename="libgazebo_ros_openni_kinect.so">
          <baseline>0.2</baseline>
          <alwaysOn>true</alwaysOn>
          <updateRate>0.0</updateRate>
          <cameraName>${prefix}camera_ir</cameraName>
          <imageTopicName>/${prefix}camera/color/image_raw</imageTopicName>
          <cameraInfoTopicName>/${prefix}camera/color/camera_info</cameraInfoTopicName>
          <depthImageTopicName>/${prefix}camera/depth/image_raw</depthImageTopicName>
          <depthImageCameraInfoTopicName>/${prefix}camera/depth/camera_info</depthImageCameraInfoTopicName>
          <pointCloudTopicName>/${prefix}camera/depth/points</pointCloudTopicName>
          <frameName>${prefix}camera_link_optical</frameName>
          <pointCloudCutoff>0.05</pointCloudCutoff>
          <pointCloudCutoffMax>3.0</pointCloudCutoffMax>
          <distortionK1>0.0</distortionK1>
          <distortionK2>0.0</distortionK2>
          <distortionK3>0.0</distortionK3>
          <distortionT1>0.0</distortionT1>
          <distortionT2>0.0</distortionT2>
          <CxPrime>0</CxPrime>
          <Cx>0</Cx>
          <Cy>0</Cy>
          <focalLength>0</focalLength>
          <hackBaseline>0</hackBaseline>
        </plugin>
      </sensor>
    </gazebo>
  </xacro:macro>

</robot>
```

```bash
#创建custom_arm.gazebo.xacro文件
gedit custom_arm.gazebo.xacro
```

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://wiki.ros.org/xacro">

  <xacro:macro name="custom_arm_gazebo">
    <!-- 为机器人添加Gazebo ROS控制插件 -->
    <gazebo>
      <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">
        <robotNamespace>/custom_arm</robotNamespace>
        <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>
        <legacyModeNS>true</legacyModeNS>
      </plugin>
    </gazebo>

    <!-- 为末端执行器添加深度相机 -->
    <gazebo reference="ee_link">
      <sensor type="depth" name="camera">
        <always_on>true</always_on>
        <update_rate>20.0</update_rate>
        <camera>
          <horizontal_fov>1.047</horizontal_fov>
          <image>
            <width>640</width>
            <height>480</height>
            <format>R8G8B8</format>
          </image>
          <clip>
            <near>0.05</near>
            <far>3.0</far>
          </clip>
        </camera>
        <plugin name="camera_controller" filename="libgazebo_ros_openni_kinect.so">
          <baseline>0.2</baseline>
          <alwaysOn>true</alwaysOn>
          <updateRate>20.0</updateRate>
          <cameraName>camera</cameraName>
          <imageTopicName>/camera/color/image_raw</imageTopicName>
          <cameraInfoTopicName>/camera/color/camera_info</cameraInfoTopicName>
          <depthImageTopicName>/camera/depth/image_raw</depthImageTopicName>
          <depthImageCameraInfoTopicName>/camera/depth/camera_info</depthImageCameraInfoTopicName>
          <pointCloudTopicName>/camera/depth/points</pointCloudTopicName>
          <frameName>camera_link</frameName>
          <pointCloudCutoff>0.05</pointCloudCutoff>
          <pointCloudCutoffMax>3.0</pointCloudCutoffMax>
          <distortionK1>0.0</distortionK1>
          <distortionK2>0.0</distortionK2>
          <distortionK3>0.0</distortionK3>
          <distortionT1>0.0</distortionT1>
          <distortionT2>0.0</distortionT2>
          <CxPrime>0</CxPrime>
          <Cx>0</Cx>
          <Cy>0</Cy>
          <focalLength>0</focalLength>
          <hackBaseline>0</hackBaseline>
        </plugin>
      </sensor>
    </gazebo>

    <!-- 设置连杆的视觉属性 -->
    <gazebo reference="base_link">
      <material>Gazebo/Blue</material>
    </gazebo>

    <gazebo reference="shoulder_link">
      <material>Gazebo/Grey</material>
    </gazebo>

    <gazebo reference="upper_arm_link">
      <material>Gazebo/Blue</material>
    </gazebo>

    <gazebo reference="forearm_link">
      <material>Gazebo/Grey</material>
    </gazebo>

    <gazebo reference="wrist_1_link">
      <material>Gazebo/Blue</material>
    </gazebo>

    <gazebo reference="wrist_2_link">
      <material>Gazebo/Grey</material>
    </gazebo>

    <gazebo reference="wrist_3_link">
      <material>Gazebo/Blue</material>
    </gazebo>

    <gazebo reference="ee_link">
      <material>Gazebo/Green</material>
    </gazebo>
  </xacro:macro>

  <xacro:custom_arm_gazebo />

</robot>
```

### 4.4 创建控制器配置文件
为了控制机械臂的关节，我们需要配置ROS控制器。创建文件 ~/catkin_ws/src/arm_obstacle_avoidance/config/arm_controllers.yaml：

```bash
cd ..
cd config/
gedit arm_controllers.yaml
```

```yaml
custom_arm:
  # 发布所有关节状态
  joint_state_controller:
    type: joint_state_controller/JointStateController
    publish_rate: 50

  # 关节轨迹控制器
  arm_controller:
    type: position_controllers/JointTrajectoryController
    joints:
      - shoulder_pan_joint
      - shoulder_lift_joint
      - elbow_joint
      - wrist_1_joint
      - wrist_2_joint
      - wrist_3_joint
    constraints:
      goal_time: 0.6
      stopped_velocity_tolerance: 0.05
      shoulder_pan_joint: {trajectory: 0.1, goal: 0.1}
      shoulder_lift_joint: {trajectory: 0.1, goal: 0.1}
      elbow_joint: {trajectory: 0.1, goal: 0.1}
      wrist_1_joint: {trajectory: 0.1, goal: 0.1}
      wrist_2_joint: {trajectory: 0.1, goal: 0.1}
      wrist_3_joint: {trajectory: 0.1, goal: 0.1}
    stop_trajectory_duration: 0.5
    state_publish_rate: 25
    action_monitor_rate: 10
```

### 4.5 创建Gazebo世界文件
接下来，我们将创建一个包含桌面和障碍物的Gazebo世界文件。创建文件 ~/catkin_ws/src/arm_obstacle_avoidance/worlds/arm_obstacle_world.world：

```bash
cd ..
cd worlds
gedit arm_obstacle_world.world
```

```xml
<?xml version="1.0" ?>
<sdf version="1.6">
  <world name="arm_obstacle_world">
    <!-- 设置物理引擎参数 -->
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
      <real_time_update_rate>1000</real_time_update_rate>
      <gravity>0 0 -9.81</gravity>
    </physics>

    <!-- 添加光源 -->
    <include>
      <uri>model://sun</uri>
    </include>

    <!-- 添加地面 -->
    <include>
      <uri>model://ground_plane</uri>
    </include>

    <!-- 添加桌子 -->
    <model name="table">
      <static>true</static>
      <pose>0.6 0 0 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>1.25 1.25 0.05</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>1.25 1.25 0.05</size>
            </box>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Wood</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

    <!-- 添加静态障碍物 - 立方体 -->
    <model name="obstacle_box">
      <static>true</static>
      <pose>0.6 0.25 0.175 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <box>
              <size>0.125 0.125 0.25</size>
            </box>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <box>
              <size>0.125 0.125 0.25</size>
            </box>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Red</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

    <!-- 添加静态障碍物 - 圆柱体 -->
    <model name="obstacle_cylinder">
      <static>true</static>
      <pose>0.8 -0.25 0.175 0 0 0</pose>
      <link name="link">
        <collision name="collision">
          <geometry>
            <cylinder>
              <radius>0.0625</radius>
              <length>0.3125</length>
            </cylinder>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <cylinder>
              <radius>0.0625</radius>
              <length>0.3125</length>
            </cylinder>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Blue</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

    <!-- 添加起点标记 -->
    <model name="start_marker">
      <static>true</static>
      <pose>0.3 0.4 0.075 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <sphere>
              <radius>0.025</radius>
            </sphere>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Green</name>
            </script>
          </material>
        </visual>
      </link>
    </model>

    <!-- 添加终点标记 -->
    <model name="goal_marker">
      <static>true</static>
      <pose>0.9 0.4 0.075 0 0 0</pose>
      <link name="link">
        <visual name="visual">
          <geometry>
            <sphere>
              <radius>0.025</radius>
            </sphere>
          </geometry>
          <material>
            <script>
              <uri>file://media/materials/scripts/gazebo.material</uri>
              <name>Gazebo/Yellow</name>
            </script>
          </material>
        </visual>
      </link>
    </model>
  </world>
</sdf>
```

### 4.6 创建启动文件
现在，我们将创建启动文件，用于启动Gazebo仿真环境、加载机械臂模型和控制器。
首先，创建一个用于加载机械臂URDF的启动文件 ~/catkin_ws/src/arm_obstacle_avoidance/launch/load_arm.launch：

```bash
cd ..
cd launch
gedit load_arm.launch
```

```xml
<?xml version="1.0"?>
<launch>
  <!-- 加载机械臂描述参数 -->
  <param name="robot_description" command="$(find xacro)/xacro '$(find arm_obstacle_avoidance)/urdf/custom_arm.urdf.xacro'" />

  <!-- 发布机器人状态 -->
  <node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" />

  <!-- 关节状态发布器 -->
  <node name="joint_state_publisher" pkg="joint_state_publisher" type="joint_state_publisher">
    <param name="use_gui" value="false" />
    <rosparam param="source_list">[/custom_arm/joint_states]</rosparam>
  </node>
</launch>
```
接下来，创建一个用于启动Gazebo和加载机械臂的启动文件 ~/catkin_ws/src/arm_obstacle_avoidance/launch/arm_gazebo.launch：

```bash
gedit arm_gazebo.launch
```



```xml
<?xml version="1.0"?>
<launch>
  <!-- 设置使用仿真时间 -->
  <param name="use_sim_time" value="true" />

  <!-- 启动Gazebo并加载世界文件 -->
  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find arm_obstacle_avoidance)/worlds/arm_obstacle_world.world"/>
    <arg name="paused" value="false"/>
    <arg name="use_sim_time" value="true"/>
    <arg name="gui" value="true"/>
    <arg name="headless" value="false"/>
    <arg name="debug" value="false"/>
  </include>

  <!-- 加载机械臂描述 -->
  <include file="$(find arm_obstacle_avoidance)/launch/load_arm.launch" />

  <!-- 在Gazebo中生成机械臂模型 -->
  <node name="spawn_model" pkg="gazebo_ros" type="spawn_model" 
        args="-urdf -param robot_description -model custom_arm 
              -x 0.6 -y 0.0 -z 0.075" 
        output="screen" />

  <!-- 加载控制器配置 -->
  <rosparam file="$(find arm_obstacle_avoidance)/config/arm_controllers.yaml" command="load" />

  <!-- 启动控制器 -->
  <node name="controller_spawner" pkg="controller_manager" type="spawner" respawn="false"
        output="screen" ns="/custom_arm" 
        args="joint_state_controller arm_controller" />

  <!-- 启动RViz进行可视化 -->
  <node name="rviz" pkg="rviz" type="rviz" args="-d $(find arm_obstacle_avoidance)/config/arm_config.rviz" />
</launch>
```

#### 编译文件

```bash
cd ~/catkin_ws
catkin_make
source devel/setup.bash
```



### 4.7 创建并配置RViz配置文件 (arm_config.rviz) 

```bash
roscore
rosrun rviz rviz
```

将fixed frame改成base_link

添加robot model和tf

在File->Save Config As中保存到config文件夹


### 4.8 创建自定义服务定义
为了实现MATLAB与ROS之间的通信，我们需要创建一个自定义的服务定义，用于请求路径规划。
首先，在包目录中创建srv目录：

```bash
mkdir -p ~/catkin_ws/src/arm_obstacle_avoidance/srv
```
然后，创建服务定义文件 ~/catkin_ws/src/arm_obstacle_avoidance/srv/RequestPlan.srv：
```srv
# 请求部分
sensor_msgs/PointCloud2 current_obstacle_map
geometry_msgs/PoseStamped current_ee_pose
float64[] current_joint_values
geometry_msgs/PoseStamped goal_ee_pose
bool validate_environment_only # 新增: 若为true, 则仅验证环境变化，不进行完整规划
---
# 响应部分
trajectory_msgs/JointTrajectory planned_trajectory # 若validate_environment_only为true且环境未显著变化，则此项可为空
bool success # 指示服务调用本身是否成功（例如，规划器是否正确执行）
string message
bool environment_has_changed_significantly # 新增: 若validate_environment_only为true，此项表示环境是否发生显著变化
```
`validate_environment_only` (请求部分): 一个布尔值。如果设置为 `true`，则服务将仅使用提供的 `current_obstacle_map` 来评估当前环境相对于上次完整规划时的环境是否发生了显著变化，而不会执行完整的路径规划。这主要用于主动避障中的环境监测。

`environment_has_changed_significantly` (响应部分): 一个布尔值。当 `validate_environment_only` 为 `true` 时，此字段指示环境中的障碍物状态是否已发生显著变化（根据 `matlab_ros_planner.m` 内部的 `detect_obstacle_changes` 逻辑判断）。如果为 `false`，表示环境相对稳定。

修改 package.xml 文件，添加服务生成依赖：

```xml
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
```
修改 CMakeLists.txt 文件，添加服务生成相关配置：
```txt
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  sensor_msgs
  geometry_msgs
  trajectory_msgs
  gazebo_ros
  gazebo_msgs
  tf2_ros
  pcl_ros
  message_generation
)

add_service_files(
  FILES
  RequestPlan.srv
)

generate_messages(
  DEPENDENCIES
  std_msgs
  sensor_msgs
  geometry_msgs
  trajectory_msgs
)

catkin_package(
  CATKIN_DEPENDS message_runtime
)
```

除了 `RequestPlan.srv` 服务定义外，为了实现MATLAB与 `planning_service.py` 之间结构化的规划结果通信，我们还需要定义一个新的自定义ROS消息。

#### 4.8.1 定义 `MatlabPlanningResult.msg` 消息

此消息将用于MATLAB规划节点向 `planning_service.py` 节点传递规划结果。

1. **创建 `msg` 目录 (如果尚不存在)：** 在您的ROS包 `arm_obstacle_avoidance` 目录下，打开终端并执行以下命令：

   Bash

   ```
   mkdir -p ~/catkin_ws/src/arm_obstacle_avoidance/msg
   ```

2. **创建 `MatlabPlanningResult.msg` 文件：** 在 `~/catkin_ws/src/arm_obstacle_avoidance/msg/` 目录下创建一个新文件，命名为 `MatlabPlanningResult.msg`。

   Bash

   ```
   gedit ~/catkin_ws/src/arm_obstacle_avoidance/msg/MatlabPlanningResult.msg
   ```

   使用文本编辑器打开此文件，并添加以下内容：

   C++

   ```c++
   # ~/catkin_ws/src/arm_obstacle_avoidance/msg/MatlabPlanningResult.msg
   # 此消息用于从MATLAB规划器向planning_service.py传递规划结果
   
   bool success                       # 规划或验证操作是否成功执行
   string message                     # 相关消息 (例如，成功信息或错误描述)
   trajectory_msgs/JointTrajectory planned_trajectory # 规划出的关节轨迹 (在仅验证模式下可为空)
   bool environment_has_changed_significantly # 新增: 指示环境与上次规划时相比是否发生显著变化
   ```

`environment_has_changed_significantly`: 一个布尔值。它对应于 `RequestPlan.srv` 响应中的同名字段，用于在 `planning_service.py` 和 `matlab_ros_planner.m` 之间传递环境变化检测的结果。

**4.8.2 更新 `package.xml`**

覆盖 `~/catkin_ws/src/arm_obstacle_avoidance/package.xml` 的内容：

```xml
<?xml version="1.0"?>
<package format="2">
  <name>arm_obstacle_avoidance</name>
  <version>0.1.0</version>
  <description>The arm_obstacle_avoidance package for active collision avoidance practice</description>

  <maintainer email="user@todo.todo">user</maintainer>
  <license>TODO</license>

  <buildtool_depend>catkin</buildtool_depend>

  <build_depend>roscpp</build_depend>
  <build_depend>rospy</build_depend>
  <build_depend>std_msgs</build_depend>
  <build_depend>sensor_msgs</build_depend>
  <build_depend>geometry_msgs</build_depend>
  <build_depend>trajectory_msgs</build_depend>
  <build_depend>gazebo_ros</build_depend>
  <build_depend>gazebo_msgs</build_depend>
  <build_depend>tf2_ros</build_depend>
  <build_depend>pcl_ros</build_depend>
  <build_depend>message_generation</build_depend> <exec_depend>roscpp</exec_depend>
  <exec_depend>rospy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>sensor_msgs</exec_depend>
  <exec_depend>geometry_msgs</exec_depend>
  <exec_depend>trajectory_msgs</exec_depend>
  <exec_depend>gazebo_ros</exec_depend>
  <exec_depend>gazebo_msgs</exec_depend>
  <exec_depend>tf2_ros</exec_depend>
  <exec_depend>pcl_ros</exec_depend>
  <exec_depend>message_runtime</exec_depend> <export>
  </export>
</package>
```

**4.8.3 更新 `CMakeLists.txt`**

覆盖 `~/catkin_ws/src/arm_obstacle_avoidance/CMakeLists.txt` 的内容：

```txt
cmake_minimum_required(VERSION 3.0.2)
project(arm_obstacle_avoidance)

## Find catkin macros and libraries
find_package(catkin REQUIRED COMPONENTS
  roscpp
  rospy
  std_msgs
  sensor_msgs
  geometry_msgs
  trajectory_msgs
  gazebo_ros
  gazebo_msgs
  tf2_ros
  pcl_ros
  message_generation # 服务和消息生成所必需
)

## Service files to be AFFECTED by generate_messages()
add_service_files(
  FILES
  RequestPlan.srv
)

## Message files to be AFFECTED by generate_messages()
add_message_files(
  FILES
  MatlabPlanningResult.msg
)

## Generate services and messages with specific dependencies
generate_messages(
  DEPENDENCIES
  std_msgs
  sensor_msgs
  geometry_msgs
  trajectory_msgs
)

## Catkin package configuration
catkin_package(
#  INCLUDE_DIRS include
#  LIBRARIES ${PROJECT_NAME}
  CATKIN_DEPENDS message_runtime roscpp rospy std_msgs sensor_msgs geometry_msgs trajectory_msgs gazebo_ros gazebo_msgs tf2_ros pcl_ros
#  DEPENDS system_lib
)

## Build
# include_directories(
# # include
#   ${catkin_INCLUDE_DIRS}
# )

## Declare a C++ library
# add_library(${PROJECT_NAME}
#   src/${PROJECT_NAME}/arm_obstacle_avoidance.cpp
# )

## Add cmake target dependencies of the library
# add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

## Declare a C++ executable
# add_executable(${PROJECT_NAME}_node src/arm_obstacle_avoidance_node.cpp)

## Add cmake target dependencies of the executable
# add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

## Specify libraries to link a library or executable target against
# target_link_libraries(${PROJECT_NAME}_node
#   ${catkin_LIBRARIES}
# )
```

### 4.9 创建路径规划服务节点

**ROS 主题接口定义：**

- 请求数据主题 (Python -> MATLAB):
  - 名称: `/matlab_planning/request_data`
  - 消息类型: `arm_obstacle_avoidance/RequestPlanRequest` (由 `RequestPlan.srv` 服务定义自动生成)
- 结果状态主题 (MATLAB -> Python):
  - 名称: `/matlab_planning/planning_status`
  - 消息类型: `arm_obstacle_avoidance/MatlabPlanningResult` (在章节 4.9.1 中定义的自定义消息)

此 `planning_service.py` 脚本创建了一个 ROS 服务节点，它是连接外部 ROS 请求与 MATLAB 内部规划能力的关键桥梁。该服务节点会通过特定的 ROS 主题与后续在章节 4.10.A 中创建的 `matlab_ros_planner.m` MATLAB 节点进行通信。**在后续的核心避障实践（章节 5.7 和 5.8）中，MATLAB 主控制脚本将通过调用此服务来请求路径规划，因此 `planning_service.py` 必须在运行这些核心脚本前被启动。**

**创建 `planning_service.py` 文件：** 文件路径: `~/src/arm_obstacle_avoidance/scripts/planning_service.py` :

```python
#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import rospy
# 导入服务定义, 服务请求的消息类型也一并导入 (例: RequestPlanRequest)
from arm_obstacle_avoidance.srv import RequestPlan, RequestPlanResponse, RequestPlanRequest
# 导入自定义的MATLAB规划结果消息类型
from arm_obstacle_avoidance.msg import MatlabPlanningResult
import threading

class PlanningServiceNode:
    def __init__(self):
        # 初始化ROS节点，名称更具体
        rospy.init_node('planning_service_node')

        # --- 内部状态，用于同步等待MATLAB的响应 ---
        self._matlab_planning_result_cache = None  # 缓存从MATLAB接收到的结果
        self._result_received_event = threading.Event() # 用于线程同步的事件

        # --- ROS Publisher: 用于将规划请求数据发送给MATLAB规划器 ---
        self._matlab_request_publisher = rospy.Publisher(
            '/matlab_planning/request_data', # 主题名称
            RequestPlanRequest,              # 消息类型 (服务请求部分)
            queue_size=5                     # 队列大小，5表示如果MATLAB处理不过来，最多缓存5条
        )
        rospy.loginfo("发布器 /matlab_planning/request_data 已创建。")

        # --- ROS Subscriber: 用于从MATLAB规划器接收规划结果 ---
        self._matlab_result_subscriber = rospy.Subscriber(
            '/matlab_planning/planning_status', # 主题名称
            MatlabPlanningResult,               # 消息类型 (自定义的结果消息)
            self._matlab_result_callback,       # 消息回调函数
            queue_size=5                        # 队列大小
        )
        rospy.loginfo("订阅器 /matlab_planning/planning_status 已创建。")

        # --- ROS Service Server: 提供给外部ROS节点的路径规划服务 ---
        self._planning_ros_service = rospy.Service(
            'request_robot_plan',             # 服务名称 (与srv文件名一致)
            RequestPlan,                      # 服务类型 (导入自srv文件)
            self._handle_ros_planning_request # 服务处理回调函数
        )
        rospy.loginfo("ROS服务 /request_robot_plan 已启动并等待请求。")
        rospy.loginfo("规划服务节点已准备就绪。")

    def _matlab_result_callback(self, msg):
        """
        当从 /matlab_planning/planning_status 主题接收到MATLAB的规划/验证结果时，此回调函数被调用。
        """
        rospy.loginfo("从MATLAB接收到规划/验证结果。成功状态: %s, 环境显著变化: %s",
                      "是" if msg.success else "否",
                      "是" if msg.environment_has_changed_significantly else "否")
        self._matlab_planning_result_cache = msg
        self._result_received_event.set()

    def _handle_ros_planning_request(self, service_req_msg):
        """
        当 /request_robot_plan 服务被调用时，此函数处理传入的请求。
        它将请求数据发布给MATLAB，然后等待MATLAB的响应或超时。
        """
        if service_req_msg.validate_environment_only:
            rospy.loginfo("处理来自ROS客户端的环境验证请求...")
        else:
            rospy.loginfo("处理来自ROS客户端的完整路径规划请求...")

        self._result_received_event.clear()
        self._matlab_planning_result_cache = None

        # 将服务请求消息 (service_req_msg，类型为RequestPlanRequest)
        # 直接发布到给MATLAB的主题。服务请求消息结构已经包含了新字段。
        try:
            # service_req_msg 本身就是 RequestPlanRequest 类型的对象，可以直接发布
            # 它包含了 current_obstacle_map, current_ee_pose, current_joint_values, 
            # goal_ee_pose, 和 validate_environment_only 字段。
            self._matlab_request_publisher.publish(service_req_msg)
            rospy.loginfo("请求数据已发布至 /matlab_planning/request_data 主题，等待MATLAB响应。")
        except Exception as e:
            rospy.logerr("发布规划/验证请求至MATLAB时发生错误: %s", str(e))
            response = RequestPlanResponse()
            response.success = False
            response.message = "ROS_SERVICE错误：未能将请求发送至MATLAB中间件: " + str(e)
            response.environment_has_changed_significantly = False # 默认为false
            return response

        timeout_seconds = 60.0 # 对于规划，可能需要更长时间
        if service_req_msg.validate_environment_only:
            timeout_seconds = 15.0 # 验证应该更快

        rospy.loginfo("等待MATLAB响应，超时时间: %.1f 秒...", timeout_seconds)

        response = RequestPlanResponse() # 初始化响应对象

        if self._result_received_event.wait(timeout=timeout_seconds):
            if self._matlab_planning_result_cache:
                rospy.loginfo("已接收并处理来自MATLAB的响应。")
                # 从缓存的结果 (类型: MatlabPlanningResult) 构建服务响应 (类型: RequestPlanResponse)
                response.planned_trajectory = self._matlab_planning_result_cache.planned_trajectory
                response.success = self._matlab_planning_result_cache.success
                response.message = self._matlab_planning_result_cache.message
                response.environment_has_changed_significantly = self._matlab_planning_result_cache.environment_has_changed_significantly
            else:
                rospy.logerr("内部错误：MATLAB结果事件已设置，但未找到存储的结果数据。")
                response.success = False
                response.message = "ROS_SERVICE错误：处理MATLAB响应时发生内部错误。"
                response.environment_has_changed_significantly = False
        else:
            rospy.logwarn("等待MATLAB响应超时（%.1f秒）。", timeout_seconds)
            response.success = False
            response.message = "ROS_SERVICE错误：等待MATLAB响应超时。"
            response.environment_has_changed_significantly = False # 在超时情况下，假设环境未确认变化

        return response # 将最终的响应返回给服务调用者

if __name__ == '__main__':
    try:
        PlanningServiceNode() # 创建并启动服务节点对象
        rospy.spin()          # 使节点保持运行，监听回调
    except rospy.ROSInterruptException:
        rospy.loginfo("规划服务节点已关闭。")
    except Exception as e_main:
        rospy.logfatal("规划服务节点发生严重错误: %s", str(e_main))
```
使脚本可执行：
```bash
chmod +x ~/catkin_ws/src/arm_obstacle_avoidance/scripts/planning_service.py
```
创建启动文件 ~/catkin_ws/src/arm_obstacle_avoidance/launch/planning_service.launch：
```xml
<?xml version="1.0"?>
<launch>
  <!-- 启动规划服务节点 -->
  <node name="planning_service" pkg="arm_obstacle_avoidance" type="planning_service.py" output="screen" />
</launch>
```
### 4.9.A 创建 MATLAB 端规划器节点(`matlab_ros_planner.m`)

为了响应 `planning_service.py` 转发的规划请求，需要在MATLAB环境中运行一个专门的ROS节点。此脚本 (`matlab_ros_planner.m`) 将订阅 `/matlab_planning/request_data` 主题，利用本指南后续章节（第五章）中定义的MATLAB核心规划函数来计算路径，然后将结果发布到 `/matlab_planning/planning_status` 主题。**此 MATLAB 节点必须在运行核心避障脚本（章节 5.7 和 5.8）之前，在 MATLAB 环境中启动并保持运行，以响应规划请求。**

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

辅助函数 `assign_and_track_obstacle_ids`:分配并追踪障碍物ID——结合卡尔曼滤波与匈牙利算法

**核心追踪流程概述：**

1. **轨迹状态定义：** 为每一个被追踪的障碍物维护一个轨迹（Track），该轨迹包含其ID、由卡尔曼滤波器估计的状态（位置和速度）、状态估计的协方差、以及其他管理信息（如年龄、可见次数等）。
2. **预测（Prediction）：** 对于每一个在上一帧存在的有效轨迹，使用其卡尔曼滤波器和运动模型来预测其在当前帧的可能状态（位置、速度）和对应的协方差。
3. **数据关联（Data Association）**：
   - **代价矩阵构建：** 计算每一个预测的轨迹与当前帧新检测到的所有原始障碍物之间的“匹配代价”。该代价是一个综合度量，考虑了预测位置与检测位置的马氏距离（Mahalanobis Distance，利用KF的协方差信息）、尺寸相似度以及方向相似度。
   - **最优分配：** 使用匈牙利算法（`matchpairs`函数）根据代价矩阵找到全局最优的匹配对（一个预测轨迹最多匹配一个新检测，一个新检测最多匹配一个预测轨迹）。
4. **更新（Update）**：
   - 对于成功匹配的轨迹-检测对，使用检测到的障碍物信息（质心、尺寸、方向）来更新对应轨迹的卡尔曼滤波器状态和协方差。同时更新轨迹的可见性计数等管理信息。
   - 被更新后的轨迹将进入下一帧的追踪循环。
5. **轨迹生命周期管理（Track Lifecycle Management）**：
   - **处理未匹配的轨迹：** 未能匹配到任何新检测的旧轨迹，其“连续不可见次数”会增加。如果连续不可见次数超过预设阈值，该轨迹将被删除。否则，它将基于预测状态继续存在。
   - **处理未匹配的检测：** 未能匹配到任何旧轨迹的新检测，将被视为潜在的新障碍物，并用于初始化一条新的轨迹。新轨迹会获得一个唯一的ID，并设定初始的KF状态和协方差。新初始化的轨迹可能需要连续几帧被成功更新才能被“确认”为稳定轨迹。

**依赖说明：** 本追踪算法的实现依赖MATLAB的 **Sensor Fusion and Tracking Toolbox™** 或 **Automated Driving Toolbox™** 中提供的 `matchpairs` 函数，用于执行匈牙利算法进行最优分配。请确保您的MATLAB环境中已安装至少其中一个工具箱。

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**运行前提：** 执行此 `matlab_ros_planner.m` 脚本之前，必须确保MATLAB环境已按照本指南第二章（特别是2.2.3节 "MATLAB中初始化ROS网络"）的说明，通过 `rosinit` 命令成功连接到ROS主控，并且正确配置了 `NodeHost`。

**创建 `matlab_ros_planner.m` 文件：** 

其内容如下：

```matlab
% matlab_ros_planner.m
% 此MATLAB脚本作为一个ROS节点运行，用于接收规划请求，执行路径规划，并发布结果。

disp('MATLAB规划节点脚本：正在初始化...'); 

% --- 全局机器人模型 ---
if isempty(ROBOT_MODEL_SINGLETON)
    disp('MATLAB规划节点：首次加载机器人模型...');
    try
        % 调用修改后的 create_robot_model 函数，禁用图形输出。
        ROBOT_MODEL_SINGLETON = create_robot_model(false); % 'false' 表示禁用图形
        disp('MATLAB规划节点：机器人模型已成功加载（图形已禁用）。');
        if isempty(ROBOT_MODEL_FOR_ACTIVE_AVOIDANCE) && ~isempty(ROBOT_MODEL_SINGLETON)
            ROBOT_MODEL_FOR_ACTIVE_AVOIDANCE = ROBOT_MODEL_SINGLETON;
            disp('MATLAB规划节点：机器人模型已复制用于主动避障变化检测。');
        end
    catch ME_model_load
        ROBOT_MODEL_SINGLETON = []; % 标记模型加载失败
        disp('MATLAB规划节点 严重错误：加载机器人模型失败。后续规划请求将无法处理。');
        disp(['错误详情: ', ME_model_load.message]);
    end
end

% --- ROS 发布器: 用于发布规划结果 ---
% 发布到 /matlab_planning/planning_status 主题, 消息类型为 arm_obstacle_avoidance/MatlabPlanningResult
try
    matlabPlanningResultPublisher = rospublisher('/matlab_planning/planning_status', ...
                                               'arm_obstacle_avoidance/MatlabPlanningResult');
    disp('MATLAB规划节点：已创建结果发布器 /matlab_planning/planning_status。');
catch ME_publisher_create
    disp('MATLAB规划节点 严重错误：创建结果发布器 /matlab_planning/planning_status 失败。');
    disp('请确保自定义消息类型 arm_obstacle_avoidance/MatlabPlanningResult 已正确生成并在MATLAB中可用，且MATLAB已连接到ROS。');
    disp(['错误详情: ', ME_publisher_create.message]);
    return; % 如果发布器创建失败，脚本无法正常工作
end
% --- ROS 发布器: 用于发布碰撞检查可视化标记 ---
try
    collisionVizPublisher = rospublisher('/collision_visualization', 'visualization_msgs/MarkerArray');
    disp('MATLAB规划节点：已创建碰撞可视化发布器 /collision_visualization。');
catch ME_collision_pub_create
    disp('MATLAB规划节点 警告：创建碰撞可视化发布器 /collision_visualization 失败。');
    disp('碰撞检查的可视化将不可用。');
    disp(['错误详情: ', ME_collision_pub_create.message]);
    collisionVizPublisher = []; % 将其置空，以便后续代码可以检查
end
% --- ROS 订阅器: 用于接收来自 planning_service.py 的规划请求数据 ---
% 订阅 /matlab_planning/request_data 主题, 消息类型为 arm_obstacle_avoidance/RequestPlanRequest
try
    matlabPlanningRequestSubscriber = rossubscriber('/matlab_planning/request_data', ...
                                                'arm_obstacle_avoidance/RequestPlanRequest', ...
                                                @matlabPlanningRequestCallback); % 指定回调函数名称
    disp('MATLAB规划节点：已创建请求订阅器 /matlab_planning/request_data。');
    disp('MATLAB规划节点正在运行，等待规划请求...');
catch ME_subscriber_create
    disp('MATLAB规划节点 严重错误：创建请求订阅器 /matlab_planning/request_data 失败。');
    disp('请确保服务消息类型 arm_obstacle_avoidance/RequestPlanRequest 在MATLAB中可用，且MATLAB已连接到ROS。');
    disp(['错误详情: ', ME_subscriber_create.message]);
    return; % 如果订阅器创建失败，脚本无法正常工作
end

% 主循环 (保持脚本运行以接收回调)
% --- 回调函数定义 ---
function matlabPlanningRequestCallback(~, rosRequestMsg)
    % 此回调函数处理来自 /matlab_planning/request_data 主题的规划或验证请求。
    % rosRequestMsg 类型为 arm_obstacle_avoidance/RequestPlanRequest (自动生成)

    % 解决方案A: 将状态变量移入回调函数内部并声明为persistent
    persistent PREVIOUS_OBSTACLES_WITH_IDS_CB; 
    persistent NEXT_OBSTACLE_ID_COUNTER_CB;    

    % 初始化回调函数内部的persistent NEXT_OBSTACLE_ID_COUNTER_CB (如果为空)
    if isempty(NEXT_OBSTACLE_ID_COUNTER_CB)
        NEXT_OBSTACLE_ID_COUNTER_CB = 1;
    end

    % ROBOT_MODEL_SINGLETON 和 ROBOT_MODEL_FOR_ACTIVE_AVOIDANCE 是脚本级 persistent 变量,
    if rosRequestMsg.ValidateEnvironmentOnly
        disp('MATLAB规划节点：收到环境验证请求。');
    else
        disp('MATLAB规划节点：收到完整路径规划请求。');
    end

    rosResultMsg = rosmessage(matlabPlanningResultPublisher); % 类型: MatlabPlanningResult

    % 增强的模型加载检查
    model_error_message = '';
    if isempty(ROBOT_MODEL_SINGLETON)
        model_error_message = 'MATLAB规划器错误：主机器人模型 ROBOT_MODEL_SINGLETON 不可用。';
    elseif rosRequestMsg.ValidateEnvironmentOnly && isempty(ROBOT_MODEL_FOR_ACTIVE_AVOIDANCE)
        model_error_message = 'MATLAB规划器错误：用于环境验证的机器人模型 ROBOT_MODEL_FOR_ACTIVE_AVOIDANCE 不可用。';
    end

    if ~isempty(model_error_message)
        disp(model_error_message);
        rosResultMsg.Success = false;
        rosResultMsg.Message = model_error_message;
        rosResultMsg.EnvironmentHasChangedSignificantly = false; % 默认为false，因为无法验证
        try
            send(matlabPlanningResultPublisher, rosResultMsg);
        catch ME_pub_err
             disp(['MATLAB规划节点：发布模型错误状态失败。详情: ', ME_pub_err.message]);
        end
        return;
    end

    try
        currentObstacleMapRosMsg = rosRequestMsg.CurrentObstacleMap;

        % 总是处理点云以获取当前的障碍物原始检测结果 (不含ID)
        disp('MATLAB规划节点：正在处理点云数据以获取原始障碍物...');
        % process_point_cloud 现在返回包含 .collisionObject 和 .centroid 的结构体数组
        [currentRawObstacleStructs, ~] = process_point_cloud(currentObstacleMapRosMsg, ROBOT_MODEL_SINGLETON, 'EnableGraphics', false); 
        disp(['MATLAB规划节点：点云处理完毕，识别到 ', num2str(length(currentRawObstacleStructs)), ' 个原始障碍物结构体。']);

        % 为当前障碍物分配ID (追踪)
        disp('MATLAB规划节点：正在为当前障碍物分配ID (追踪)...');
        % assign_and_track_obstacle_ids 是一个即将定义的新辅助函数
        % 它会更新 NEXT_OBSTACLE_ID_COUNTER
        [currentObstaclesWithAssignedIDs, NEXT_OBSTACLE_ID_COUNTER_CB] = ...
    assign_and_track_obstacle_ids(PREVIOUS_OBSTACLES_WITH_IDS_CB, currentRawObsStructs, NEXT_OBSTACLE_ID_COUNTER_CB);
        disp(['MATLAB规划节点：ID分配/追踪完成，当前有效障碍物数量: ', num2str(length(currentObstaclesWithAssignedIDs))]);

        if rosRequestMsg.ValidateEnvironmentOnly
            % --- 执行环境变化验证 ---
            % PREVIOUS_OBSTACLES_WITH_IDS_CB 是上次规划后带有ID的障碍物列表
            % currentObstaclesWithAssignedIDs 是当前帧处理并分配/追踪ID后的障碍物列表
            if isempty(PREVIOUS_OBSTACLES_WITH_IDS_CB) && ~isempty(currentObstaclesWithAssignedIDs)
                disp('MATLAB规划节点：先前无障碍物记录，但当前检测到障碍物，视为环境变化。');
                rosResultMsg.EnvironmentHasChangedSignificantly = true;
            elseif isempty(PREVIOUS_OBSTACLES_WITH_IDS_CB) && isempty(currentObstaclesWithAssignedIDs)
                 disp('MATLAB规划节点：先前无障碍物记录，当前也无障碍物，视为环境未变化。');
                rosResultMsg.EnvironmentHasChangedSignificantly = false;
            else % PREVIOUS_OBSTACLES_WITH_IDS_CB 不为空
                disp('MATLAB规划节点：执行基于ID的障碍物变化检测...');
                % 定义阈值 (这些可以从外部配置或作为服务参数传入)
                positionChangeThreshold_m = 0.07;       % 位置变化容忍度 (米)
                sizeChangeThreshold_m = 0.04;         % 尺寸变化容忍度 (米)
                orientationChangeThreshold_rad = deg2rad(15); % 方向变化容忍度 (弧度)
                newObstacleCountThreshold = 1;          % 新出现多少个障碍物算显著变化
                disappearedObstacleCountThreshold = 1;  % 消失多少个障碍物算显著变化
                
                % 调用修改后的 detect_obstacle_changes_planner_version
                environmentChanged = detect_obstacle_changes_planner_version(...
                                                              PREVIOUS_OBSTACLES_WITH_IDS_CB, ...
                                                              currentObstaclesWithAssignedIDs, ...
                                                              positionChangeThreshold_m, ...
                                                              sizeChangeThreshold_m, ...
                                                              orientationChangeThreshold_rad, ...
                                                              newObstacleCountThreshold, ...
                                                              disappearedObstacleCountThreshold);
                rosResultMsg.EnvironmentHasChangedSignificantly = environmentChanged;
                if environmentChanged
                    disp('MATLAB规划节点：检测到环境发生显著变化。');
                else
                    disp('MATLAB规划节点：未检测到环境发生显著变化。');
                end
            end
            rosResultMsg.Success = true; % 验证操作本身成功
            rosResultMsg.Message = '环境验证完成。';
            % PlannedTrajectory 默认为空
        else
            % --- 执行完整路径规划 ---
            disp('MATLAB规划节点：开始完整路径规划流程...');
            currentJointValuesArray = double(rosRequestMsg.CurrentJointValues);
            goalEePoseRosMsg = rosRequestMsg.GoalEePose;

            numRobotJoints = numel(ROBOT_MODEL_SINGLETON.homeConfiguration);
            if length(currentJointValuesArray) ~= numRobotJoints
                error('MATLAB规划器错误：接收到的current_joint_values数组长度与机器人模型关节数量不匹配。');
            end
            currentConfigVector = currentJointValuesArray(:)';

            disp('MATLAB规划节点：正在使用逆运动学计算目标关节配置...');
            goalPositionVector = [goalEePoseRosMsg.Pose.Position.X, goalEePoseRosMsg.Pose.Position.Y, goalEePoseRosMsg.Pose.Position.Z];
            goalOrientationQuat = [goalEePoseRosMsg.Pose.Orientation.W, goalEePoseRosMsg.Pose.Orientation.X, goalEePoseRosMsg.Pose.Orientation.Y, goalEePoseRosMsg.Pose.Orientation.Z];
            goalTargetTransform = trvec2tform(goalPositionVector);
            goalTargetTransform(1:3, 1:3) = quat2rotm(goalOrientationQuat);

            ikSolverInstance = inverseKinematics('RigidBodyTree', ROBOT_MODEL_SINGLETON);
            ikSolverWeights = [0.25 0.25 0.25 1 1 1];
            initialGuessConfigStruct = ROBOT_MODEL_SINGLETON.homeConfiguration;
            for j_idx = 1:numRobotJoints
                initialGuessConfigStruct(j_idx).JointPosition = currentConfigVector(j_idx);
            end
            robotEndEffectorName = 'tool0';
            [goalConfigAsStruct, ikSolutionInfo] = ikSolverInstance(robotEndEffectorName, goalTargetTransform, ikSolverWeights, initialGuessConfigStruct);

            if ~strcmpi(ikSolutionInfo.Status, 'success')
                errorMsgIK = sprintf('MATLAB规划器错误：逆运动学未能找到解。状态: %s。', ikSolutionInfo.Status);
                disp(errorMsgIK); % 记录错误到控制台
                rosResultMsg.Success = false;
                rosResultMsg.Message = errorMsgIK;
                % rosResultMsg.PlannedTrajectory 保持为空
                rosResultMsg.EnvironmentHasChangedSignificantly = false; % 规划失败，环境变化状态未评估或不适用
                try
                    send(matlabPlanningResultPublisher, rosResultMsg);
                catch ME_pub_err
                     disp(['MATLAB规划节点：发布IK失败状态失败。详情: ', ME_pub_err.message]);
                end
                return; % 从回调函数提前返回
            end
            goalConfigVector = zeros(1, numRobotJoints);
            for j_idx = 1:numRobotJoints
                goalConfigVector(j_idx) = goalConfigAsStruct(j_idx).JointPosition;
            end
            disp('MATLAB规划节点：逆运动学成功。');

            disp('MATLAB规划节点：正在执行RRT路径规划...');
            % 提取 collisionObject 列表给 plan_path
            obstacleCollisionObjectsForPlanner = cell(1, length(currentObstaclesWithAssignedIDs));
            for obs_idx = 1:length(currentObstaclesWithAssignedIDs)
                obstacleCollisionObjectsForPlanner{obs_idx} = currentObstaclesWithAssignedIDs{obs_idx}.collisionObject;
            end

            disp('MATLAB规划节点：正在执行RRT路径规划 (使用当前识别的障碍物)...');
            [plannedPathRRT, rrtSuccessFlag] = plan_path(ROBOT_MODEL_SINGLETON, currentConfigVector, goalConfigVector, obstacleCollisionObjectsForPlanner, false);

            if ~rrtSuccessFlag
                errorMsgRRT = 'MATLAB规划器错误：RRT路径规划算法失败。';
                disp(errorMsgRRT); % 记录错误到控制台
                rosResultMsg.Success = false;
                rosResultMsg.Message = errorMsgRRT;
                % rosResultMsg.PlannedTrajectory 保持为空
                rosResultMsg.EnvironmentHasChangedSignificantly = false; % 规划失败，环境变化状态未评估或不适用
                try
                    send(matlabPlanningResultPublisher, rosResultMsg);
                catch ME_pub_err
                     disp(['MATLAB规划节点：发布RRT失败状态失败。详情: ', ME_pub_err.message]);
                end
                return; % 从回调函数提前返回
            end
            disp('MATLAB规划节点：RRT路径规划成功。');

            if ~isempty(plannedPathRRT) && ~isempty(collisionVizPublisher) && ~isempty(ROBOT_MODEL_SINGLETON)
                disp('MATLAB规划节点：对最终路径上的采样点进行碰撞检查并可视化...');
                numPointsOnPath = size(plannedPathRRT, 1);
                % 选择路径上的几个点进行可视化，例如起点、终点和中间几个点
                % 避免可视化过多点导致RViz卡顿
                numSamplesToVisualize = min(10, numPointsOnPath); % 最多可视化10个点
                sampleIndices = round(linspace(1, numPointsOnPath, numSamplesToVisualize));

                % 获取用于碰撞检查的障碍物列表 (这些是规划时使用的障碍物)
                % obstacleCollisionObjectsForPlanner 已在前面定义并传递给了 plan_path
                % 此处再次确认其可用性
                activeObstacleSetForCheck = {};
                if exist('obstacleCollisionObjectsForPlanner','var') && iscell(obstacleCollisionObjectsForPlanner)
                    activeObstacleSetForCheck = obstacleCollisionObjectsForPlanner;
                else
                    disp('MATLAB规划节点 警告: obstacleCollisionObjectsForPlanner 未定义或不是cell数组，无法对路径点进行碰撞可视化。');
                end

                if ~isempty(activeObstacleSetForCheck)
                    for k_path_vis = 1:length(sampleIndices)
                        path_idx = sampleIndices(k_path_vis);
                        config_on_path = plannedPathRRT(path_idx, :);

                        % 将行向量转换为 rigidBodyTree 需要的结构体形式
                        currentConfigStructForCheck = ROBOT_MODEL_SINGLETON.homeConfiguration;
                        for j_struct_idx = 1:length(config_on_path)
                             if j_struct_idx <= length(currentConfigStructForCheck)
                                currentConfigStructForCheck(j_struct_idx).JointPosition = config_on_path(j_struct_idx);
                             end
                        end

                        % 执行实际的碰撞检查
                        % checkCollision(robotModel, configuration, obstaclesCellArray, 'Exhaustive', 'on')
                        % 'Exhaustive','on' 会检查所有连杆对，可能较慢，但更全面
                        % 默认情况下，checkCollision 会检查机器人与给定障碍物的碰撞
                        % 以及机器人自身的自碰撞（如果障碍物列表为空或未提供）
                        % 此处我们检查机器人与环境障碍物的碰撞
                        isPathPointColliding = checkCollision(ROBOT_MODEL_SINGLETON, currentConfigStructForCheck, activeObstacleSetForCheck);
                        % checkCollision 返回一个 NxM 逻辑矩阵，N是机器人连杆数，M是障碍物数量
                        % 如果任何一个元素为 true，则表示该连杆与对应障碍物碰撞
                        % 或者，如果想得到一个单一的碰撞状态（机器人是否与任何障碍物碰撞）：
                        % isPathPointColliding = any(checkCollision(ROBOT_MODEL_SINGLETON, currentConfigStructForCheck, activeObstacleSetForCheck), 'all');
                        % 对于自碰撞: isSelfColliding = any(checkCollision(ROBOT_MODEL_SINGLETON, currentConfigStructForCheck), 'all'); (不传入障碍物)

                        % 这里我们简化为：只要与环境中的任何一个障碍物发生碰撞，就认为是碰撞
                        finalCollisionState = false; % 默认为无碰撞
                        if ~isempty(isPathPointColliding) && islogical(isPathPointColliding)
                            if any(isPathPointColliding(:)) % 检查是否有任何一个碰撞发生
                                finalCollisionState = true;
                            end
                        end
                        % （可选）加入自碰撞检查
                        % isSelfColliding = any(checkCollision(ROBOT_MODEL_SINGLETON, currentConfigStructForCheck), 'all');
                        % finalCollisionState = finalCollisionState || isSelfColliding;

                        % 调用可视化函数
                        uniqueMarkerId = path_idx + floor(posixtime(datetime('now'))*100); % 保证ID的独特性
                        visualize_single_config_collision_status(ROBOT_MODEL_SINGLETON, config_on_path, finalCollisionState, uniqueMarkerId, collisionVizPublisher);
                        pause(0.05); % 短暂暂停以便RViz有时间渲染
                    end
                    disp('MATLAB规划节点：最终路径点的碰撞状态可视化（部分点）已发送。');
                end
            end
            % --- 碰撞检查与可视化结束 ---

            disp('MATLAB规划节点：正在生成 trajectory_msgs/JointTrajectory 格式的ROS消息...');
            robotJointNamesList = cell(1, numRobotJoints);
            for j_idx = 1:numRobotJoints
                robotJointNamesList{j_idx} = ROBOT_MODEL_SINGLETON.Bodies{j_idx}.Joint.Name; % 确保 ROBOT_MODEL_SINGLETON 在此作用域可用
            end
            trajectoryRosMsg = generate_trajectory_from_states(plannedPathRRT, robotJointNamesList);
            disp('MATLAB规划节点：轨迹ROS消息已生成。');

            rosResultMsg.Success = true;
            rosResultMsg.Message = 'MATLAB规划器：路径已成功规划。';
            rosResultMsg.PlannedTrajectory = trajectoryRosMsg;
            rosResultMsg.EnvironmentHasChangedSignificantly = false; % 对于新规划的路径，相对于当前地图，环境自然是“未变化”的

            % 存储当前带有ID的障碍物列表，用于下一次环境变化检测
            PREVIOUS_OBSTACLES_WITH_IDS_CB = currentObstaclesWithAssignedIDs;
            disp('MATLAB规划节点：已更新用于变化检测的带ID障碍物基准列表。');
        end

    catch ME_planning_pipeline
        disp('MATLAB规划节点 在处理流程中发生错误。');
        disp(['错误信息: ', ME_planning_pipeline.message]);
        if ~isempty(ME_planning_pipeline.stack)
            disp('错误栈追踪:');
            for k_err = 1:length(ME_planning_pipeline.stack)
                disp(ME_planning_pipeline.stack(k_err));
            end
        end
        rosResultMsg.Success = false;
        rosResultMsg.Message = ['MATLAB规划器错误：', ME_planning_pipeline.message];
        rosResultMsg.EnvironmentHasChangedSignificantly = false; % 出错时默认为false
    end

    try
        rospublish(matlabPlanningResultPublisher, rosResultMsg);
        if rosResultMsg.Success
            disp(['MATLAB规划节点：已成功发布处理结果（状态：成功, 环境变化: ', num2str(rosResultMsg.EnvironmentHasChangedSignificantly), '）。']);
        else
            disp(['MATLAB规划节点：已发布处理结果（状态：失败）：', rosResultMsg.Message]);
        end
    catch ME_publish_response
        disp('MATLAB规划节点 严重错误：发布最终处理结果失败。');
        disp(['错误详情: ', ME_publish_response.message]);
    end
end

% --------------------------------------------------------------------
% 辅助函数: 检测障碍物变化 (基于ID追踪)
% --------------------------------------------------------------------
function changed = detect_obstacle_changes_planner_version(oldObsWithIDs, newObsWithIDs, ...
                                                          position_thresh_m, size_thresh_m, orientation_thresh_rad, ...
                                                          new_obstacle_count_trigger, disappeared_obstacle_count_trigger)
    % oldObsWithIDs, newObsWithIDs: 单元数组，每个元素是 {id, collisionObject, centroid}
    % *_thresh_*: 各种变化的阈值
    % new_obstacle_count_trigger: 新出现多少个障碍物就认为环境显著变化
    % disappeared_obstacle_count_trigger: 消失多少个障碍物就认为环境显著变化

    changed = false;

    if isempty(oldObsWithIDs) && isempty(newObsWithIDs)
        disp('detect_changes_id: 无旧障碍物也无新障碍物，环境未变。');
        changed = false;
        return;
    end
    
    if isempty(oldObsWithIDs) && ~isempty(newObsWithIDs)
        if length(newObsWithIDs) >= new_obstacle_count_trigger
            disp(['detect_changes_id: 原无障碍物，现出现 ', num2str(length(newObsWithIDs)), ' 个，超过阈值 ', num2str(new_obstacle_count_trigger), '。环境变化。']);
            changed = true;
        else
            disp(['detect_changes_id: 原无障碍物，现出现 ', num2str(length(newObsWithIDs)), ' 个，未超阈值。环境未变。']);
            changed = false;
        end
        return;
    end

    if ~isempty(oldObsWithIDs) && isempty(newObsWithIDs)
        if length(oldObsWithIDs) >= disappeared_obstacle_count_trigger
            disp(['detect_changes_id: 原有障碍物 ', num2str(length(oldObsWithIDs)), ' 个，现全部消失，超过阈值 ', num2str(disappeared_obstacle_count_trigger), '。环境变化。']);
            changed = true;
        else
            disp(['detect_changes_id: 原有障碍物 ', num2str(length(oldObsWithIDs)), ' 个，现全部消失，未超阈值。环境未变。']);
            changed = false;
        end
        return;
    end

    % 创建ID到索引的映射，方便查找
    oldMap = containers.Map('KeyType','double','ValueType','any');
    for i = 1:length(oldObsWithIDs)
        oldMap(oldObsWithIDs{i}.id) = oldObsWithIDs{i};
    end

    newMap = containers.Map('KeyType','double','ValueType','any');
    for i = 1:length(newObsWithIDs)
        newMap(newObsWithIDs{i}.id) = newObsWithIDs{i};
    end

    allOldIDs = cellfun(@(c) c.id, oldObsWithIDs);
    allNewIDs = cellfun(@(c) c.id, newObsWithIDs);

    commonIDs = intersect(allOldIDs, allNewIDs);
    newlyAppearedIDs = setdiff(allNewIDs, allOldIDs);
    disappearedIDs = setdiff(allOldIDs, allNewIDs);

    % 检查共同障碍物的变化
    for i = 1:length(commonIDs)
        id = commonIDs(i);
        oldObsStruct = oldMap(id);
        newObsStruct = newMap(id);
        
        oldCo = oldObsStruct.collisionObject;
        newCo = newObsStruct.collisionObject;

        % 1. 比较类型 (如果类型可以变化的话，目前都是collisionBox)
        if ~strcmp(class(oldCo), class(newCo))
            disp(['detect_changes_id: ID ', num2str(id), ' 类型从 ', class(oldCo), ' 变为 ', class(newCo), '。环境变化。']);
            changed = true; return;
        end

        % 2. 比较位置 (基于质心，因为Pose可能是相对于物体几何中心的)
        pos_diff = norm(oldObsStruct.centroid - newObsStruct.centroid);
        if pos_diff > position_thresh_m
            disp(['detect_changes_id: ID ', num2str(id), ' 位置变化 (', num2str(pos_diff*1000, '%.1f'), 'mm) > 阈值 (', num2str(position_thresh_m*1000, '%.1f'), 'mm)。环境变化。']);
            changed = true; return;
        end

        % 3. 比较尺寸 (仅针对 collisionBox)
        if isa(oldCo, 'collisionBox') && isa(newCo, 'collisionBox')
            oldDims = [oldCo.X, oldCo.Y, oldCo.Z];
            newDims = [newCo.X, newCo.Y, newCo.Z];
            % 比较每个维度或者总体积/范数等
            if any(abs(oldDims - newDims) > size_thresh_m) % 如果任何一个维度变化超过阈值
                 size_diff_norm = norm(oldDims - newDims); % 或者用范数比较
                 disp(['detect_changes_id: ID ', num2str(id), ' Box尺寸变化 (范数 ', num2str(size_diff_norm, '%.3f'),'m) > 阈值 (', num2str(size_thresh_m, '%.3f'),'m)。环境变化。']);
                 changed = true; return;
            end
        % 可以在此添加对 collisionCylinder, collisionSphere 的尺寸比较
        elseif isa(oldCo, 'collisionCylinder') && isa(newCo, 'collisionCylinder')
            if abs(oldCo.Radius - newCo.Radius) > size_thresh_m || abs(oldCo.Length - newCo.Length) > size_thresh_m
                disp(['detect_changes_id: ID ', num2str(id), ' Cylinder尺寸变化 > 阈值。环境变化。']);
                changed = true; return;
            end
        elseif isa(oldCo, 'collisionSphere') && isa(newCo, 'collisionSphere')
            if abs(oldCo.Radius - newCo.Radius) > size_thresh_m
                disp(['detect_changes_id: ID ', num2str(id), ' Sphere尺寸变化 > 阈值。环境变化。']);
                changed = true; return;
            end
        end
        
        % 4. 比较方向 (从Pose矩阵中提取旋转部分)
        oldRotm = oldCo.Pose(1:3, 1:3); 
        newRotm = newCo.Pose(1:3, 1:3);
        % 计算两个旋转矩阵之间的角度差 (轴角表示法的角度)
        relativeRotm = newRotm * oldRotm'; % R_new * R_old_transpose
        [~, angle_diff_rad_val] = rotm2axang(relativeRotm); % 返回 [axis, angle]
        
        % angle_diff_rad_val 可能为负，取绝对值比较
        if abs(angle_diff_rad_val) > orientation_thresh_rad 
            disp(['detect_changes_id: ID ', num2str(id), ' 方向变化 (', num2str(rad2deg(abs(angle_diff_rad_val)), '%.1f'), 'deg) > 阈值 (', num2str(rad2deg(orientation_thresh_rad), '%.1f'), 'deg)。环境变化。']);
            changed = true; return;
        end
    end

    % 检查新出现的障碍物数量
    if length(newlyAppearedIDs) >= new_obstacle_count_trigger
        disp(['detect_changes_id: 新出现障碍物数量 (', num2str(length(newlyAppearedIDs)), ') >= 阈值 (', num2str(new_obstacle_count_trigger), ')。环境变化。']);
        changed = true; return;
    end

    % 检查消失的障碍物数量
    if length(disappearedIDs) >= disappeared_obstacle_count_trigger
        disp(['detect_changes_id: 消失障碍物数量 (', num2str(length(disappearedIDs)), ') >= 阈值 (', num2str(disappeared_obstacle_count_trigger), ')。环境变化。']);
        changed = true; return;
    end
    
    % 如果以上都没有触发变化，则认为环境未显著变化
    if ~changed
        disp('detect_changes_id: 未检测到显著的环境变化。');
    end
end


function trajMsg = generate_trajectory_from_states(pathStates, jointNames)
    % pathStates: 路径点矩阵，每行是一个关节配置
    % jointNames: 关节名称单元数组

    if isempty(pathStates)
        error('路径状态为空，无法生成轨迹');
    end

    waypoints = pathStates';  % 转置为 numJoints x numPoints

    numSamples = max(100, size(waypoints, 2) * 5);
    if size(waypoints, 2) == 1 % 如果只有一个路径点 (例如，IK结果直接是目标)
        % 创建一个只有单点的轨迹，或者根据需求复制该点作为起点和终点
         q = waypoints;
         qd = zeros(size(waypoints));
         qdd = zeros(size(waypoints));
         tvec = [0, 0.1]; % 短时间
         q = [q,q]; % 复制点
         qd = [qd,qd];
         qdd = [qdd,qdd];
         numSamples = 2;
    else
        [q, qd, qdd, tvec] = trapveltraj(waypoints, numSamples);
    end

    trajMsg = rosmessage('trajectory_msgs/JointTrajectory');
    trajMsg.JointNames = jointNames;

    for i_traj = 1:numSamples
        point = rosmessage('trajectory_msgs/JointTrajectoryPoint');
        point.Positions = q(:,i_traj)';
        point.Velocities = qd(:,i_traj)';
        point.Accelerations = qdd(:,i_traj)';
        point.TimeFromStart = rosduration(tvec(i_traj));
        trajMsg.Points(i_traj) = point;
    end

    disp(['生成了包含 ', num2str(numSamples), ' 个点的轨迹']);
end

% --------------------------------------------------------------------
% 辅助函数: 分配并追踪障碍物ID (基于卡尔曼滤波和匈牙利算法的鲁棒追踪)
% --------------------------------------------------------------------
function [currentTracks, updatedNextID] = assign_and_track_obstacle_ids(prevTracks, currentRawObsStructs, nextIDSeed, dt, frameCount)
    % assign_and_track_obstacle_ids: 对检测到的障碍物进行追踪和ID分配。
    %
    % 输入:
    %   prevTracks (struct array): 上一帧的轨迹结构体数组。每个结构体包含:
    %                               .id (double) - 轨迹ID
    %                               .kf (kalmanFilter) - 卡尔曼滤波器对象
    %                               .age (double) - 轨迹的年龄 (帧数)
    %                               .totalVisibleCount (double) - 总共被看到的次数
    %                               .consecutiveInvisibleCount (double) - 连续未被看到的次数
    %                               .dims (1x3 double) - [L, W, H] for collisionBox
    %                               .orientation (3x3 double) - 旋转矩阵
    %                               .collisionObject (collisionShape) - 障碍物的碰撞体
    %                               .lastDetectionCentroid (1x3 double) - 上次检测到的质心
    %   currentRawObsStructs (cell array): 当前帧原始检测到的障碍物结构体单元数组。
    %                                      每个单元是 {collisionObject, centroid}。
    %   nextIDSeed (double): 用于生成新轨迹ID的起始计数器。
    %   dt (double): 自上一帧以来的时间间隔 (秒)。
    %   frameCount (double): 当前处理的帧计数或时间戳，用于调试或特定逻辑。
    %
    % 输出:
    %   currentTracks (struct array): 当前帧更新后的轨迹结构体数组。
    %   updatedNextID (double): 更新后的轨迹ID计数器。

    % --- 初始化和追踪参数 ---
    updatedNextID = nextIDSeed;
    numPrevTracks = length(prevTracks);
    numDetections = length(currentRawObsStructs);

    % 轨迹生命周期管理参数 (这些参数的调优见后续说明章节)
    gateThresholdMahalanobis = 2.5; % 马氏距离门控阈值 (基于卡方分布，例如2.5对应约95%置信区间对于2D)
    costOfNonAssignment = 10;       % 未分配的代价，用于matchpairs函数
    invisibleForTooLong = 3;        % 轨迹连续多少帧未匹配到检测则删除 (帧数)
    ageThresholdForDeletion = 1;    % 对于年龄较小的轨迹，如果很快就丢失，可以更快删除
    minHitsForReliableTrack = 3;    % 至少需要多少次成功匹配才认为是一个比较可靠的轨迹

    % 代价函数权重 (这些参数的调优见后续说明章节)
    w_pos_normalized = 0.6; % 位置代价权重 (马氏距离已包含不确定性，此处权重针对组合)
    w_size = 0.2;           % 尺寸代价权重
    w_orient = 0.2;         % 方向代价权重

    currentTracks = []; % 初始化当前帧的轨迹列表

    % --- 步骤 1: 对已存在轨迹进行状态预测 (卡尔曼滤波器) ---
    if numPrevTracks > 0
        for i = 1:numPrevTracks
            % 预测轨迹i在当前时刻的状态
            % predict函数会更新 prevTracks(i).kf 内部的状态和协方差
            prevTracks(i).predictedState = predict(prevTracks(i).kf, dt);
            prevTracks(i).predictedCovariance = prevTracks(i).kf.StateCovariance; % 获取预测后的协方差
        end
    end

    % --- 步骤 2: 构建代价矩阵用于匈牙利算法 ---
    costMatrix = Inf(numPrevTracks, numDetections); % 初始化代价矩阵

    if numPrevTracks > 0 && numDetections > 0
        for i = 1:numPrevTracks % 遍历每一个旧轨迹
            track = prevTracks(i);
            predictedCentroid = track.predictedState(1:3)'; % KF状态的前3个元素是位置 [cx, cy, cz]

            for j = 1:numDetections % 遍历每一个新检测
                detection = currentRawObsStructs{j};
                measuredCentroid = detection.centroid;
                measuredCollisionObject = detection.collisionObject;

                % 2a. 门控: 使用马氏距离进行初步筛选
                % S = H * P_pred * H' + R
                % H = [eye(3) zeros(3,3)]; % 测量矩阵，因为我们只测量位置
                % R = track.kf.MeasurementNoise; % 从KF对象获取测量噪声协方差
                % innovationCov = H * track.predictedCovariance * H' + R;
                % mahalanobisDist = sqrt(mahal(measuredCentroid, predictedCentroid, innovationCov));
                % 上述mahal函数直接用可能会有问题，我们手动计算平方马氏距离
                measurementResidual = measuredCentroid - predictedCentroid;
                H_matrix = [eye(3) zeros(3,3)]; % 测量矩阵
                residualCovariance = H_matrix * track.predictedCovariance * H_matrix' + track.kf.MeasurementNoise;
                
                % 检查 residualCovariance 是否正定且可逆
                if det(residualCovariance) <= 1e-9 % 或者用chol分解检查
                    % disp(['警告: 轨迹 ', num2str(track.id), ' 的残差协方差矩阵奇异或接近奇异，跳过此检测对。']);
                    mahalanobisDistSq = Inf; % 若奇异，则代价无穷大
                else
                    mahalanobisDistSq = measurementResidual * (residualCovariance \ measurementResidual'); % 平方马氏距离
                end


                if mahalanobisDistSq > gateThresholdMahalanobis^2 % 使用平方进行比较，避免开方
                    costMatrix(i,j) = Inf; % 超出验证门，代价设为无穷大
                    continue;
                end

                % 2b. 计算详细代价 (对于门内的候选对)
                cost_pos = sqrt(mahalanobisDistSq); % 使用马氏距离作为位置代价的一部分

                % 提取尺寸和方向用于计算代价 (需要辅助函数)
                [trackDims, trackOrientationMatrix] = extractGeometricFeatures(track.collisionObject); % 使用上一帧的实际检测物体
                [detectionDims, detectionOrientationMatrix] = extractGeometricFeatures(measuredCollisionObject);

                % 尺寸代价 (归一化体积差异或维度差异)
                if isempty(trackDims) || isempty(detectionDims) || numel(trackDims) ~= numel(detectionDims)
                    cost_size = 1.0; % 如果无法比较尺寸，则惩罚较大 (0到1范围)
                else
                    % 示例：归一化L2范数差异
                    size_diff_norm = norm(trackDims - detectionDims);
                    size_mean_norm = norm((trackDims + detectionDims)/2);
                    if size_mean_norm < 1e-3, size_mean_norm = 1e-3; end %避免除零
                    cost_size = min(1.0, size_diff_norm / size_mean_norm); % 限制在[0,1]
                end

                % 方向代价 (0到1范围, 0表示方向一致, 1表示方向差异最大)
                if isempty(trackOrientationMatrix) || isempty(detectionOrientationMatrix)
                    cost_orient = 1.0; % 如果任一方向无效
                else
                    R_relative = detectionOrientationMatrix * trackOrientationMatrix';
                    [~, angle_diff_rad] = rotm2axang(R_relative);
                    cost_orient = abs(angle_diff_rad) / pi; % 归一化到[0,1] (0到pi的角度差)
                end
                
                % 总代价: 加权和
                % 注意：马氏距离本身是有统计意义的，直接加权可能不完全严谨，
                % 但在实际工程中常作为一种组合方式。
                % 此处将马氏距离视为一种归一化的位置差异指标。
                normalized_pos_cost = min(1.0, cost_pos / gateThresholdMahalanobis); % 将马氏距离也归一化到[0,1]附近
                
                costMatrix(i,j) = w_pos_normalized * normalized_pos_cost + ...
                                  w_size * cost_size + ...
                                  w_orient * cost_orient;
            end
        end
    end

    % --- 步骤 3: 使用匈牙利算法 (matchpairs) 进行分配 ---
    if numPrevTracks > 0 && numDetections > 0
        % matchpairs(CostMatrix, CostOfNonAssignment, 'max true for max cost, false for min cost');
        % 我们希望最小化代价，所以第三个参数应该是 'min' (matchpairs 默认行为) 或不指定
        % matchpairs 的输出:
        %   matches: P-by-2 matrix, P是匹配对的数量。每行 [trackIdx, detectionIdx]
        %   unassignedTracks: 未匹配上的轨迹索引
        %   unassignedDetections: 未匹配上的检测索引
        [matches, unassignedTracksIdx, unassignedDetectionsIdx] = matchpairs(costMatrix, costOfNonAssignment);
    else % 如果没有轨迹或没有检测
        matches = zeros(0,2); % 空匹配
        unassignedTracksIdx = (1:numPrevTracks)';
        unassignedDetectionsIdx = (1:numDetections)';
    end

    % --- 步骤 4: 更新匹配上的轨迹 ---
    matchedTrackIDs = [];
    for k = 1:size(matches, 1)
        trackIdx = matches(k,1);
        detectionIdx = matches(k,2);

        trackToUpdate = prevTracks(trackIdx);
        detectionForUpdate = currentRawObsStructs{detectionIdx};
        
        % 使用检测到的质心更新KF
        measuredCentroid = detectionForUpdate.centroid;
        % correct 函数会更新 trackToUpdate.kf 内部的状态和协方差
        trackToUpdate.correctedState = correct(trackToUpdate.kf, measuredCentroid', dt); % measurement z needs to be column vector
        
        % 更新轨迹的其他属性
        trackToUpdate.age = trackToUpdate.age + 1;
        trackToUpdate.totalVisibleCount = trackToUpdate.totalVisibleCount + 1;
        trackToUpdate.consecutiveInvisibleCount = 0; % 重置不可见计数
        trackToUpdate.collisionObject = detectionForUpdate.collisionObject; % 更新为最新的碰撞体
        [trackToUpdate.dims, trackToUpdate.orientation] = extractGeometricFeatures(trackToUpdate.collisionObject);
        trackToUpdate.lastDetectionCentroid = measuredCentroid;

        currentTracks = [currentTracks; trackToUpdate];
        matchedTrackIDs = [matchedTrackIDs; trackToUpdate.id];
    end

    % --- 步骤 5: 处理未匹配的轨迹 (可能删除) ---
    for k = 1:length(unassignedTracksIdx)
        trackIdx = unassignedTracksIdx(k);
        trackToManage = prevTracks(trackIdx);

        trackToManage.consecutiveInvisibleCount = trackToManage.consecutiveInvisibleCount + 1;
        trackToManage.age = trackToManage.age + 1; % 年龄继续增长

        % 删除逻辑
        % 过于老旧且长时间不可见，或者非常年轻但很快就丢失
        shouldDelete = false;
        if trackToManage.consecutiveInvisibleCount > invisibleForTooLong
            shouldDelete = true;
            disp(['MATLAB规划节点(追踪): 轨迹 ', num2str(trackToManage.id), ' 因长时间(',num2str(trackToManage.consecutiveInvisibleCount),')不可见而被删除。年龄: ', num2str(trackToManage.age), ', 总可见: ', num2str(trackToManage.totalVisibleCount)]);
        end
        % （可选）对于不够可靠的轨迹，如果丢失也较快删除
        if trackToManage.totalVisibleCount < minHitsForReliableTrack && trackToManage.consecutiveInvisibleCount > ageThresholdForDeletion
             shouldDelete = true;
             disp(['MATLAB规划节点(追踪): 年轻轨迹 ', num2str(trackToManage.id), ' 因很快丢失而被删除。年龄: ', num2str(trackToManage.age), ', 总可见: ', num2str(trackToManage.totalVisibleCount)]);
        end


        if ~shouldDelete
            % 如果不删除，则保留该轨迹，其状态是基于预测的
            % KF对象内部已经通过predict更新了状态和协方差
            trackToManage.correctedState = trackToManage.predictedState; % 将预测状态视为当前状态
            % collisionObject, dims, orientation 保持上一帧成功检测时的值
            currentTracks = [currentTracks; trackToManage];
        end
    end

    % --- 步骤 6: 初始化新的轨迹 (来自未匹配的检测) ---
    for k = 1:length(unassignedDetectionsIdx)
        detectionIdx = unassignedDetectionsIdx(k);
        newDetection = currentRawObsStructs{detectionIdx};

        % 创建新的轨迹结构体
        newTrack.id = updatedNextID;
        updatedNextID = updatedNextID + 1;

        % 初始化卡尔曼滤波器
        % 状态向量: [cx, cy, cz, vx, vy, vz]'
        % 初始位置来自检测，初始速度设为0 (或基于最近几帧粗略估计，此处简化为0)
        initialState = [newDetection.centroid(1); newDetection.centroid(2); newDetection.centroid(3); 0; 0; 0];
        
        % 定义初始状态协方差 P0 (具体数值见调优章节)
        % 通常位置不确定性来自检测噪声，速度不确定性初始较大
        initialStateCovariance = diag([0.1^2, 0.1^2, 0.1^2, 0.5^2, 0.5^2, 0.5^2]); % 例: 位置标准差0.1m, 速度标准差0.5m/s

        % 定义过程噪声协方差 Q (具体数值见调优章节)
        % Q = G * G' * sigma_acc^2, G = [dt^2/2; dt^2/2; dt^2/2; dt; dt; dt]
        % 更简单的方式是直接定义对角阵，主要影响速度分量
        sigma_pos_proc = 0.05; % 过程噪声中位置的标准差 (m) - 体现模型未建模的随机位移
        sigma_vel_proc = 0.2;  % 过程噪声中速度的标准差 (m/s) - 体现模型未建模的加速度
        processNoiseCov = diag([sigma_pos_proc^2, sigma_pos_proc^2, sigma_pos_proc^2, ...
                                sigma_vel_proc^2, sigma_vel_proc^2, sigma_vel_proc^2]);
        
        % 定义测量噪声协方差 R (具体数值见调优章节)
        % 假设测量的是[cx, cy, cz]
        sigma_meas_pos = 0.05; % 传感器对质心位置测量的标准差 (m)
        measurementNoiseCov = diag([sigma_meas_pos^2, sigma_meas_pos^2, sigma_meas_pos^2]);

        newTrack.kf = kalmanFilter(@cvkf_motionModel, @cvkf_measurementModel, initialState, ...
                                   'StateCovariance', initialStateCovariance, ...
                                   'ProcessNoise', processNoiseCov, ...
                                   'MeasurementNoise', measurementNoiseCov, ...
                                   'StateTransitionFcn', @(x, dt_kf) cvkf_stateTransition(x, dt_kf, frameCount), ... % 传递dt和frameCount
                                   'MeasurementFcn', @cvkf_measurement);
        
        newTrack.age = 1;
        newTrack.totalVisibleCount = 1;
        newTrack.consecutiveInvisibleCount = 0;
        newTrack.collisionObject = newDetection.collisionObject;
        [newTrack.dims, newTrack.orientation] = extractGeometricFeatures(newTrack.collisionObject);
        newTrack.predictedState = initialState; % 初始预测即为初始状态
        newTrack.correctedState = initialState; % 初始修正也为初始状态
        newTrack.lastDetectionCentroid = newDetection.centroid;

        currentTracks = [currentTracks; newTrack];
        disp(['MATLAB规划节点(追踪): 初始化新轨迹 ID: ', num2str(newTrack.id)]);
    end
    
    % (可选) 对currentTracks按ID排序，方便调试查看
    if ~isempty(currentTracks)
        [~, sortIdx] = sort([currentTracks.id]);
        currentTracks = currentTracks(sortIdx);
    end

    disp(['MATLAB规划节点(追踪): 追踪完成。当前有效轨迹数量: ', num2str(length(currentTracks)), ...
          ', 下一个可用ID: ', num2str(updatedNextID)]);

end

% --- 卡尔曼滤波器辅助函数 ---
function x_next = cvkf_motionModel(x_curr, dt_kf_ignored)
    % cvkf_motionModel: 匀速运动模型的状态转移函数 (用于kalmanFilter的Process属性)
    % x_curr: 当前状态 [cx; cy; cz; vx; vy; vz]
    % dt_kf_ignored: 此处dt由StateTransitionFcn的输入参数提供，这里可以忽略
    %
    % 注意: kalmanFilter对象的 'Process' 属性如果直接设为一个函数句柄，
    % 该函数不应依赖外部传入的dt。dt应通过 'StateTransitionFcn' 的方式传入。
    % 但为了兼容性或不同用法，此处保留dt参数，实际由StateTransitionFcn使用。
    % 或者，直接让 'Process' 为空，完全依赖 'StateTransitionFcn'。
    % 为清晰起见，此处 motionModel 假定 dt 已经通过某种方式获得了，
    % 但在实际的 kalmanFilter 调用中，我们使用 StateTransitionFcn 来处理 dt。
    % 因此，这个函数主要用于概念展示，实际的转移由cvkf_stateTransition完成。
    dt = 0.1; % 假设一个名义上的dt，实际由StateTransitionFcn覆盖
    F = [1 0 0 dt 0  0;
         0 1 0 0  dt 0;
         0 0 1 0  0  dt;
         0 0 0 1  0  0;
         0 0 0 0  1  0;
         0 0 0 0  0  1];
    x_next = F * x_curr;
end

function F = cvkf_stateTransition(x_curr_ignored, dt_kf, frameCount_ignored)
    % cvkf_stateTransition: 返回匀速运动模型的离散时间状态转移矩阵 F
    % x_curr_ignored: 当前状态 (未使用，因为F不依赖于x_curr)
    % dt_kf: 时间步长
    % frameCount_ignored: 当前帧计数 (未使用，但保留接口以备将来扩展)
    F = [1 0 0 dt_kf 0  0;
         0 1 0 0  dt_kf 0;
         0 0 1 0  0  dt_kf;
         0 0 0 1  0  0;
         0 0 0 0  1  0;
         0 0 0 0  0  1];
end

function z_meas = cvkf_measurementModel(x_curr)
    % cvkf_measurementModel: 测量模型函数 (用于kalmanFilter的MeasurementFcn属性)
    % x_curr: 当前状态 [cx; cy; cz; vx; vy; vz]
    % 输出 z_meas: 测量到的量 [cx; cy; cz]
    H = [1 0 0 0 0 0;
         0 1 0 0 0 0;
         0 0 1 0 0 0];
    z_meas = H * x_curr;
end

function H_matrix = cvkf_measurement(x_curr_ignored)
    % cvkf_measurement: 返回测量矩阵 H (用于kalmanFilter的MeasurementJacobianFcn，如果测量模型非线性)
    % 或者直接在创建KF时指定。此处提供一个函数形式。
    % 对于线性测量，可以直接在创建KF时使用 MeasurementModel 属性指定H矩阵。
    % 如果 kalmanFilter 的 'MeasurementFcn' 提供了非线性函数，则需要
    % 'MeasurementJacobianFcn'。由于我们的测量模型是线性的 (z = Hx),
    % MeasurementFcn 可以直接返回 Hx, 或者更简单地，在创建 kalmanFilter 对象时
    % 不设置 MeasurementFcn, 而是让 H 矩阵通过 predict 和 correct 的内部机制处理。
    % 此处命名为cvkf_measurement是为了与KF对象的MeasurementFcn参数对应。
    % 然而，更标准的做法是若测量模型为 z = Hx，则 KF 的 measurement update 使用 H。
    % 此函数返回的应是 H 矩阵本身，如果 MeasurementFcn 被设置成这个函数的话，
    % kalmanFilter 对象会期望它返回测量值 z，而不是 H。
    % 更好的方式是在创建 kalmanFilter 时不指定 MeasurementFcn, 而让其使用默认的线性假设，
    % 或者在 correct 函数中显式提供 H 矩阵（如果该函数签名支持）。
    %
    % 在 MATLAB R2018b 及以后版本的 kalmanFilter 对象中，如果测量是线性的 z = Hx + v,
    % 你通常不需要定义 MeasurementFcn 和 MeasurementJacobianFcn。
    % 只需要在 correct(kf, z_meas) 时，kf 对象内部知道 H (通常从创建时推断或默认)。
    % 如果 measurement model 是非线性的 z = h(x) + v, 则需要 MeasurementFcn h(x)
    % 和 MeasurementJacobianFcn (雅可比矩阵 H = dh/dx)。
    %
    % 为了与上面 assign_and_track_obstacle_ids 中手动计算 residualCovariance 的 H_matrix 一致，
    % 这里我们定义一个返回 H 矩阵的函数，尽管它可能不直接用于 kalmanFilter 的 MeasurementFcn。
    H_matrix = [1 0 0 0 0 0;
                0 1 0 0 0 0;
                0 0 1 0 0 0];
end


% --- 几何特征提取辅助函数 ---
function [dims, orientationMatrix, shapeType] = extractGeometricFeatures(collisionObj)
    % extractGeometricFeatures: 从 collisionShape 对象中提取尺寸和方向。
    % 输入:
    %   collisionObj (collisionShape): 如 collisionBox, collisionCylinder, collisionSphere
    % 输出:
    %   dims (1xN double): 尺寸向量。
    %       - collisionBox: [Length, Width, Height] (X, Y, Z 维度)
    %       - collisionCylinder: [Radius, Length]
    %       - collisionSphere: [Radius]
    %       - 其他或无法识别: []
    %   orientationMatrix (3x3 double): 旋转矩阵。对于球体，返回 eye(3)。
    %                                  如果无法获取，返回 []。
    %   shapeType (string): "box", "cylinder", "sphere", or "unknown"

    dims = [];
    orientationMatrix = [];
    shapeType = "unknown";

    if isa(collisionObj, 'collisionBox')
        dims = [collisionObj.X, collisionObj.Y, collisionObj.Z]; % X, Y, Z 对应 Length, Width, Height
        orientationMatrix = collisionObj.Pose(1:3, 1:3);
        shapeType = "box";
    elseif isa(collisionObj, 'collisionCylinder')
        dims = [collisionObj.Radius, collisionObj.Length];
        orientationMatrix = collisionObj.Pose(1:3, 1:3);
        shapeType = "cylinder";
    elseif isa(collisionObj, 'collisionSphere')
        dims = [collisionObj.Radius];
        orientationMatrix = eye(3); % 球体对称，方向通常不重要或设为单位阵
        shapeType = "sphere";
    else
        disp('警告: 未知或不支持的碰撞对象类型，无法提取几何特征。');
    end
end
% --------------------------------------------------------------------
% 辅助函数: 可视化单个配置的碰撞检查状态
% --------------------------------------------------------------------
function visualize_single_config_collision_status(robotModel, configArray, isColliding, markerId, collisionMarkerPublisher)
    % robotModel: 机械臂的 rigidBodyTree 模型
    % configArray: 要可视化的单个关节配置 (行向量)
    % isColliding (logical): 该配置是否发生碰撞
    % markerId (integer): 用于此标记的唯一ID
    % collisionMarkerPublisher: 用于发布 visualization_msgs/MarkerArray 的 rospublisher 对象

    if isempty(collisionMarkerPublisher)
        return; % 如果发布器未成功创建，则不执行任何操作
    end

    markerArrayMsg = rosmessage(collisionMarkerPublisher); % 创建 MarkerArray 消息

    % 计算末端执行器在给定配置下的位姿
    % 确保configArray是列向量以用于getTransform
    currentConfigStruct = robotModel.homeConfiguration; % 获取结构体形式的配置
    for j_idx_vis = 1:length(configArray)
        if j_idx_vis <= length(currentConfigStruct)
             currentConfigStruct(j_idx_vis).JointPosition = configArray(j_idx_vis);
        end
    end
    eeTform = getTransform(robotModel, currentConfigStruct, 'tool0'); % 假设末端执行器名为 'tool0'

    % 创建可视化标记 (Sphere)
    markerMsg = rosmessage('visualization_msgs/Marker');
    markerMsg.Header.FrameId = 'base_link'; % 假设相对于 base_link 可视化
    markerMsg.Header.Stamp = rostime('now');
    markerMsg.Ns = 'collision_check_status'; % 命名空间
    markerMsg.Id = int32(markerId); % 确保为整数类型
    markerMsg.Type = markerMsg.SPHERE; % 球体标记
    markerMsg.Action = markerMsg.ADD;

    % 设置标记位姿 (球心位于末端执行器位置)
    markerMsg.Pose.Position.X = eeTform(1,4);
    markerMsg.Pose.Position.Y = eeTform(2,4);
    markerMsg.Pose.Position.Z = eeTform(3,4);
    markerMsg.Pose.Orientation.W = 1.0; % 默认方向

    % 设置标记尺寸
    markerMsg.Scale.X = 0.06;
    markerMsg.Scale.Y = 0.06;
    markerMsg.Scale.Z = 0.06;

    % 根据碰撞状态设置颜色
    if isColliding
        markerMsg.Color.R = 1.0; % 红色表示碰撞
        markerMsg.Color.G = 0.0;
        markerMsg.Color.B = 0.0;
    else
        markerMsg.Color.R = 0.0; % 绿色表示无碰撞
        markerMsg.Color.G = 1.0;
        markerMsg.Color.B = 0.0;
    end
    markerMsg.Color.A = 0.8; % 透明度

    markerMsg.Lifetime = rosduration(2.0); % 标记持续时间 (例如2秒)

    markerArrayMsg.Markers(1) = markerMsg; % 将单个标记添加到数组
    send(collisionMarkerPublisher, markerArrayMsg); % 发布标记数组
end
```

### 4.10 创建完整的启动文件

最后，创建一个启动文件，用于启动整个系统。创建文件 ~/catkin_ws/src/arm_obstacle_avoidance/launch/arm_obstacle_avoidance.launch：
```xml
<?xml version="1.0"?>
<launch>
  <!-- 启动Gazebo和机械臂 -->
  <include file="$(find arm_obstacle_avoidance)/launch/arm_gazebo.launch" />
  
  <!-- 启动规划服务 -->
  <include file="$(find arm_obstacle_avoidance)/launch/planning_service.launch" />
</launch>
```

注意：此启动文件通过 `<include file="$(find arm_obstacle_avoidance)/launch/planning_service.launch" />` 保证了 `planning_service.py` 节点会随主仿真环境一同启动。**这是实现服务化规划的关键步骤。**

### 4.11 编译和运行

完成上述所有文件的创建后，我们需要编译ROS包并运行仿真：
```bash
# 返回工作空间根目录
cd ~/catkin_ws

# 编译工作空间
catkin_make

# 设置环境变量
source devel/setup.bash

# 运行仿真
roslaunch arm_obstacle_avoidance arm_obstacle_avoidance.launch
```
这将启动Gazebo仿真环境、加载机械臂模型、启动控制器、启动规划服务。

### 4.12 与MATLAB集成
为了将ROS环境与MATLAB集成，需要在MATLAB中设置ROS网络连接。确保已按照第2.2节的说明配置了MATLAB与ROS的网络通信。
在MATLAB中，使用以下代码连接到ROS网络：

```matlab
% 连接到ROS网络
rosinit('http://YOUR_UBUNTU_VM_IP:11311', 'NodeHost', 'YOUR_WINDOWS_HOST_IP');

% 检查连接是否成功
rostopic list
```
替换 YOUR_UBUNTU_VM_IP 和 YOUR_WINDOWS_HOST_IP 为实际的IP地址。

### 4.13 测试机械臂控制
在MATLAB中，可以使用以下代码发送简单的轨迹命令到机械臂：
```matlab
% 创建轨迹发布者
trajPub = rospublisher('/custom_arm/arm_controller/command', 'trajectory_msgs/JointTrajectory');

% 创建轨迹消息
trajMsg = rosmessage(trajPub);
trajMsg.JointNames = {'shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint', ...
                      'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint'};

% 创建轨迹点
point1 = rosmessage('trajectory_msgs/JointTrajectoryPoint');
point1.Positions = [0, 0, 0, 0, 0, 0];  % 初始位置
point1.TimeFromStart = rosduration(0);

point2 = rosmessage('trajectory_msgs/JointTrajectoryPoint');
point2.Positions = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5];  % 目标位置
point2.TimeFromStart = rosduration(2);

% 添加轨迹点到轨迹消息
trajMsg.Points = [point1, point2];

% 发送轨迹命令
send(trajPub, trajMsg);
```

### 4.14 测试点云数据接收
在MATLAB中，可以使用以下代码接收深度相机的点云数据：
```matlab
% 创建点云订阅者
pointCloudSub = rossubscriber('/camera/depth/points', 'sensor_msgs/PointCloud2');

% 等待接收点云数据
pointCloudMsg = receive(pointCloudSub, 10);

% 将点云数据转换为MATLAB点云对象
pointCloud = readXYZ(pointCloudMsg);

% 显示点云
figure;
pcshow(pointCloud);
title('深度相机点云数据');
```
### 4.15 测试规划服务
本章节演示如何从 MATLAB 中调用先前在章节 4.10 中创建的 `/request_robot_plan` ROS 服务。**这种通过服务客户端请求路径规划的方法，将是后续核心避障（5.7 `arm_obstacle_avoidance.m` 和 5.8 `active_obstacle_avoidance.m`）实际采用的机制。** 因此，理解这里的代码逻辑对于后续章节至关重要。以下代码展示了如何构建服务请求、发送请求并处理响应：
```matlab
% 创建服务客户端
planClient = rossvcclient('/request_robot_plan', 'arm_obstacle_avoidance/RequestPlan');

% 创建请求消息
planReq = rosmessage(planClient);

% 填充请求字段
% 当前点云数据
planReq.CurrentObstacleMap = pointCloudMsg;

% 当前末端执行器位姿
planReq.CurrentEePose = rosmessage('geometry_msgs/PoseStamped');
planReq.CurrentEePose.Header.FrameId = 'base_link';
planReq.CurrentEePose.Header.Stamp = rostime('now');
planReq.CurrentEePose.Pose.Position.X = 0.2;
planReq.CurrentEePose.Pose.Position.Y = 0.0;
planReq.CurrentEePose.Pose.Position.Z = 0.4;
planReq.CurrentEePose.Pose.Orientation.W = 1.0;

% 当前关节角度
planReq.CurrentJointValues = [0, 0, 0, 0, 0, 0];

% 目标末端执行器位姿
planReq.GoalEePose = rosmessage('geometry_msgs/PoseStamped');
planReq.GoalEePose.Header.FrameId = 'base_link';
planReq.GoalEePose.Header.Stamp = rostime('now');
planReq.GoalEePose.Pose.Position.X = 0.7;
planReq.GoalEePose.Pose.Position.Y = 0.2;
planReq.GoalEePose.Pose.Position.Z = 0.25;
planReq.GoalEePose.Pose.Orientation.W = 1.0;

% 调用服务
planResp = call(planClient, planReq, 'Timeout', 10);

% 检查响应
if planResp.Success
    disp('规划成功');
    disp(['消息: ', planResp.Message]);
    
    % 获取规划的轨迹
    plannedTrajectory = planResp.PlannedTrajectory;
    
    % 发送轨迹到机械臂控制器
    send(trajPub, plannedTrajectory);
else
    disp('规划失败');
    disp(['错误消息: ', planResp.Message]);
end
```



## 5. 实现核心功能：MATLAB-ROS交互与运动规划循环

### 5.1 准备MATLAB环境
#### 5.1.1 检查并安装必要的工具箱
在MATLAB命令窗口中运行以下命令，检查是否已安装所需的工具箱：
```matlab
ver('robotics')
ver('ros')
```

#### 5.1.2 配置MATLAB与ROS通信
按照第2.2节的说明，配置MATLAB与ROS的网络通信。在MATLAB中创建一个脚本文件connect_to_ros.m：
```matlab
function ros_master_uri = connect_to_ros()
    % connect_to_ros: 尝试连接到ROS Master，并处理现有连接。

    % 默认IP地址 (可以被用户输入覆盖)
    default_ros_ip = '192.168.110.100';
    default_host_ip = '192.168.1.101'; % Windows主机的IP

    % --- 1. 从用户获取目标ROS Master的IP地址 ---
    ros_ip_input = input(['请输入Ubuntu VM的IP地址 (默认: ', default_ros_ip, '): '], 's');
    if isempty(ros_ip_input)
        ros_ip = default_ros_ip;
        disp(['使用默认Ubuntu VM IP地址: ', ros_ip]);
    else
        ros_ip = ros_ip_input;
    end

    host_ip_input = input(['请输入Windows主机的IP地址 (默认: ', default_host_ip, '): '], 's');
    if isempty(host_ip_input)
        host_ip = default_host_ip;
        disp(['使用默认Windows主机 IP地址: ', host_ip]);
    else
        host_ip = host_ip_input;
    end
    ros_master_uri_target = ['http://', ros_ip, ':11311'];

    % --- 2. 检查并处理现有的ROS连接 ---
    try
        % 使用内部API检查全局节点状态
        node_instance = matlabshared.ros.internal.GlobalMATLABROSNode.getInstance;
        is_node_valid_and_connected = ~isempty(node_instance) && ...
                                      ~isempty(node_instance.getNode) && ...
                                      node_instance.Connected;

        if is_node_valid_and_connected
            current_master_uri = rosmaster.URI; % 尝试获取当前Master URI
            if ~isempty(current_master_uri)
                disp(['MATLAB已连接到ROS主节点: ', current_master_uri]);
                if strcmp(current_master_uri, ros_master_uri_target)
                    disp('当前连接与目标一致，无需重新连接。');
                    ros_master_uri = current_master_uri;
                    return; % 成功，直接返回
                else
                    disp(['当前连接 (', current_master_uri, ') 与目标 (', ros_master_uri_target, ') 不一致。']);
                    disp('将尝试关闭现有连接并连接到目标。');
                    rosshutdown;
                    pause(2); % 等待关闭完成
                end
            else
                disp('MATLAB节点实例存在且已连接，但无法获取Master URI。可能连接已损坏。');
                disp('将尝试关闭现有连接并重新建立。');
                rosshutdown;
                pause(2); % 等待关闭完成
            end
        else
            disp('未检测到活动的、已连接的MATLAB ROS节点。');
            % 如果存在节点实例但未连接，也尝试关闭以确保干净状态
            if ~isempty(node_instance) && ~isempty(node_instance.getNode)
                disp('检测到未连接的节点实例，尝试关闭...');
                rosshutdown;
                pause(2);
            end
            disp('将尝试建立新连接。');
        end
    catch ME_check
        disp(['检查现有ROS连接时发生错误: ', ME_check.message]);
        disp('假设无有效连接或连接状态异常，将尝试重置并建立新连接。');
        try
            rosshutdown; % 尝试关闭以防部分初始化或损坏状态
            pause(2);
        catch ME_shutdown_early
            disp(['在连接检查失败后尝试关闭ROS时出错: ', ME_shutdown_early.message]);
        end
    end

    % --- 3. 尝试初始化新的ROS连接 (带重试机制) ---
    maxAttempts = 3;
    attempt = 0;
    connected = false;
    ros_master_uri = ''; % 初始化返回的URI为空

    while ~connected && attempt < maxAttempts
        attempt = attempt + 1;
        try
            disp(['尝试连接到 ROS Master (', ros_master_uri_target, ') 使用NodeHost (', host_ip, ') (第 ', num2str(attempt), '/', num2str(maxAttempts), ' 次)...']);
            rosinit(ros_master_uri_target, 'NodeHost', host_ip);
            
            pause(1); % 短暂暂停，让连接状态稳定
            current_master_uri_check = rosmaster.URI; % 再次确认连接后的MasterURI
            
            if isempty(current_master_uri_check) % 有时rosinit不报错但连接未完全建立
                 error('MATLAB:ROS:NoMasterConnectionPostInit', 'rosinit 调用后未能确认到 ROS Master 的连接。');
            end

            disp(['成功连接到ROS主节点: ', current_master_uri_check]);
            ros_master_uri = current_master_uri_check; % 将实际连接上的URI赋给输出变量
            connected = true;

        catch ex
            disp(['连接失败 (第 ', num2str(attempt), ' 次): ', ex.message]);
            
            disp('尝试关闭任何可能存在的ROS连接以准备重试...');
            try
                rosshutdown;
                pause(2); % 等待关闭完成
            catch ME_shutdown_retry
                disp(['在重试前关闭ROS时出错: ', ME_shutdown_retry.message]);
            end

            if attempt < maxAttempts
                disp(['等待5秒后重试连接到 (', ros_master_uri_target, ')...']);
                pause(5);
            else
                disp('已达到最大尝试次数，连接失败。');
                ros_master_uri = ''; % 确保在最终失败时返回空
            end
        end
    end
end
```
### 5.2 创建机械臂模型

创建create_robot_model.m脚本

```matlab
function robot = create_robot_model(enableGraphics)
% create_robot_model: 创建并返回一个基于D-H参数的rigidBodyTree机械臂模型。
    %
    % 输入:
    %   enableGraphics (logical): 可选参数。如果为 true (默认) 或未提供，则显示模型。
    %                             如果为 false，则不执行任何绘图操作。
    %
    % 输出:
    %   robot (rigidBodyTree): 构建好的机械臂模型对象。

    % 参数默认值处理
    if nargin < 1
        enableGraphics = true; % 如果未提供参数，则默认启用图形显示
    end

    % 创建一个刚体树对象 (rigidBodyTree) 用于表示机械臂模型。
    % 'DataFormat', 'column' 指定关节位置等数据以列向量形式存储。
    % 'MaxNumBodies' 预分配空间，可以略大于实际连杆数，以提高添加连杆时的效率。
    robot = rigidBodyTree('DataFormat', 'column', 'MaxNumBodies', 10);
    disp('MATLAB (create_robot_model): rigidBodyTree 对象已初始化。');

    % --------------------------------------------------------------------
    % 标准Denavit-Hartenberg (D-H)参数定义
    % --------------------------------------------------------------------
    % 格式: [a, alpha, d, theta_offset]
    % a (link length): 连杆长度 - Z(i-1)轴与Z(i)轴之间的公垂线长度，沿X(i)轴的平移。
    % alpha (link twist): 连杆扭转角 - Z(i-1)轴与Z(i)轴之间的夹角，绕X(i)轴的旋转。
    % d (link offset): 连杆偏距 - X(i-1)轴与X(i)轴之间沿Z(i-1)轴的距离。
    % theta_offset (joint angle offset): 关节角偏置 - X(i-1)轴与X(i)轴之间的夹角，绕Z(i-1)轴的旋转。
    %                                     对于转动关节，实际关节角 = 关节变量 + theta_offset。

    % 修改后的几何常量值 (目标：主要臂展约1米)
    % 这些值是基于之前示例值乘以缩放因子约1.25得到的。
    % 您必须确保URDF文件中对应的<xacro:property>也使用了这些更新后的值。
    d1_val = 0.1875; % 基座到肩部旋转中心的高度
    a2_val = 0.375;  % 肩关节到肘关节的长度
    a3_val = 0.3125; % 肘关节到腕部某点的长度
    d4_val = 0.15;   % 腕部沿轴线的偏移1
    d5_val = 0.10;   % 腕部沿轴线的偏移2
    d6_val = 0.0875; % 腕部末端到法兰盘的偏移

    gripper_base_offset_val = 0.0375; % 法兰盘到夹爪基座(ee_link)的距离
    tcp_offset_val = 0.1875;          % 夹爪基座(ee_link)到TCP(tool0)的距离

    % D-H参数表 - 使用修改后的长度值。
    % 角度参数 (alpha, theta_offset) 通常在尺寸缩放中保持不变，因为它们定义的是相对姿态。
    % 这里的theta_offset都为0，是基于URDF中<origin rpy="..."> 和 <axis xyz="0 0 1"/> 已经正确建立了D-H约定的坐标系。
    dhparams_table = [ %  a_i      alpha_i   d_i         theta_i_offset
                      0,        pi/2,   d1_val,     0;  % 关节 1 (shoulder_pan_joint)
                      a2_val,   0,      0,          0;  % 关节 2 (shoulder_lift_joint)
                      a3_val,   0,      0,          0;  % 关节 3 (elbow_joint)
                      0,        pi/2,   d4_val,     0;  % 关节 4 (wrist_1_joint)
                      0,        -pi/2,  d5_val,     0;  % 关节 5 (wrist_2_joint)
                      0,        0,      d6_val,     0;  % 关节 6 (wrist_3_joint)
    ];

    % --------------------------------------------------------------------
    % 定义连杆和关节的名称 (必须与URDF文件中的名称完全一致)
    % --------------------------------------------------------------------
    linkNames_arm = { % 机械臂的活动连杆名称
        'shoulder_link',    % 第一个活动连杆，由关节1驱动
        'upper_arm_link',   % 第二个活动连杆，由关节2驱动
        'forearm_link',     % 第三个活动连杆，由关节3驱动
        'wrist_1_link',     % 第四个活动连杆，由关节4驱动
        'wrist_2_link',     % 第五个活动连杆，由关节5驱动
        'wrist_3_link'      % 第六个活动连杆 (法兰盘)，由关节6驱动
    };
    
    jointNames_arm = { % 机械臂的活动关节名称
        'shoulder_pan_joint', % 关节 1
        'shoulder_lift_joint',% 关节 2
        'elbow_joint',        % 关节 3
        'wrist_1_joint',      % 关节 4
        'wrist_2_joint',      % 关节 5
        'wrist_3_joint'       % 关节 6
    };
    
    % --------------------------------------------------------------------
    % 循环添加机械臂的基本连杆和关节到模型中
    % --------------------------------------------------------------------
    current_parent_link_name = robot.BaseName; % 获取机器人模型的基座名称 (默认为 'base')

    for i = 1:size(dhparams_table, 1) % 遍历D-H参数表的每一行，对应一个关节和它驱动的连杆
        % 创建一个新的刚体对象 (连杆)
        body_i = rigidBody(linkNames_arm{i}); 
        
        % 创建一个新的关节对象, 类型为旋转关节 ('revolute')
        joint_i = rigidBodyJoint(jointNames_arm{i}, 'revolute'); 
        
        % 使用该行D-H参数设置关节的固定变换。
        % 'dh' 字符串指定了参数遵循标准D-H约定: [a, alpha, d, theta_offset]
        setFixedTransform(joint_i, dhparams_table(i,:), 'dh'); 
        
        % 将创建的关节赋给当前创建的连杆
        body_i.Joint = joint_i; 
        
        % 将当前连杆 (body_i) 添加到机器人模型 (robot) 中，并指定其父连杆
        addBody(robot, body_i, current_parent_link_name); 
        
        % 更新父连杆名称为当前连杆的名称，为下一次迭代做准备
        current_parent_link_name = linkNames_arm{i}; 
    end
    
    % --------------------------------------------------------------------
    % 添加末端执行器安装点 (ee_link) - 作为固定连杆
    % --------------------------------------------------------------------
    % ee_link 代表夹爪或其他工具的物理安装基座。
    % 它通过一个固定关节连接到机械臂的最后一个活动连杆 (wrist_3_link)。
    
    body_ee_link = rigidBody('ee_link'); % 创建名为 'ee_link' 的刚体对象
    joint_to_ee_link = rigidBodyJoint('wrist_3_to_ee_link_joint', 'fixed'); % 创建连接到ee_link的固定关节

    % 定义从 wrist_3_link (最后一个活动连杆) 到 ee_link 的静态变换。
    % 此变换必须与URDF文件中 'wrist_3_to_ee_link_joint' 的 <origin> 标签所定义的几何关系完全一致。
    % URDF中定义: <origin xyz="0 0 ${gripper_base_offset}" rpy="0 0 0"/>
    % 使用更新后的 gripper_base_offset_val
    tform_wrist3_to_ee = trvec2tform([0, 0, gripper_base_offset_val]); % 仅Z轴平移
    
    % 如果URDF中ee_link相对于wrist_3_link还有旋转，需要在这里构建包含旋转的变换矩阵:
    % rpy_wrist3_to_ee_val = [roll, pitch, yaw]; % 从URDF <origin rpy="..."> 获取
    % rotm_wrist3_to_ee_val = eul2rotm(fliplr(rpy_wrist3_to_ee_val), 'ZYX'); % 注意RPY到旋转矩阵的转换约定
    % tform_wrist3_to_ee = rt2tr(rotm_wrist3_to_ee_val, [0; 0; gripper_base_offset_val]);

    setFixedTransform(joint_to_ee_link, tform_wrist3_to_ee); % 设置固定变换
    body_ee_link.Joint = joint_to_ee_link; % 将关节赋给ee_link刚体
    addBody(robot, body_ee_link, linkNames_arm{end}); % 添加ee_link到 wrist_3_link (即 current_parent_link_name)

    % --------------------------------------------------------------------
    % 添加工具中心点 (tool0) - 作为固定连杆
    % --------------------------------------------------------------------
    % tool0 代表机械臂末端工具的实际操作点 (TCP - Tool Center Point)。
    % 路径规划通常是针对 tool0 来进行的。
    % tool0 通过一个固定关节连接到 ee_link (夹爪基座)。
    
    body_tool0 = rigidBody('tool0'); % 创建名为 'tool0' 的刚体对象
    joint_to_tool0 = rigidBodyJoint('ee_link_to_tool0_joint', 'fixed'); % 创建连接到tool0的固定关节

    % 定义从 ee_link 到 tool0 的静态变换。
    % 此变换必须与URDF文件中 'ee_link_to_tool0_joint' 的 <origin> 标签所定义的几何关系完全一致。
    % URDF中示例定义: <origin xyz="0 0 ${tcp_offset}" rpy="0 0 0"/> (简单对齐示例)
    % 或 <origin xyz="0 0 ${tcp_offset}" rpy="${pi/2} 0 ${pi/2}"/> (特定朝向示例)
    % 使用更新后的 tcp_offset_val
    tform_ee_to_tool0_translation = [0, 0, tcp_offset_val];

    % 假设tool0与ee_link坐标系轴向一致，仅平移 (对应URDF中rpy="0 0 0")：
    tform_ee_to_tool0 = trvec2tform(tform_ee_to_tool0_translation);

    % 如果URDF中为tool0定义了特定的旋转 (例如 rpy_tool0_urdf = [roll, pitch, yaw]):
    % rpy_tool0_from_urdf = [pi/2, 0, pi/2]; % 假设这是URDF中定义的RPY值
    % % 将URDF的RPY (通常是X-Y-Z内旋) 转换为MATLAB的旋转矩阵
    % % URDF RPY (R,P,Y) -> R = Rot(X,R)*Rot(Y,P)*Rot(Z,Y) (intrinsic)
    % % MATLAB eul2rotm([Y,P,R],'ZYX') (extrinsic)
    % rotm_tool0 = eul2rotm([rpy_tool0_from_urdf(3), rpy_tool0_from_urdf(2), rpy_tool0_from_urdf(1)], 'ZYX');
    % tform_ee_to_tool0 = rt2tr(rotm_tool0, tform_ee_to_tool0_translation);
    
    setFixedTransform(joint_to_tool0, tform_ee_to_tool0); % 设置固定变换
    body_tool0.Joint = joint_to_tool0; % 将关节赋给tool0刚体
    addBody(robot, body_tool0, 'ee_link'); % 添加tool0到ee_link

    % --------------------------------------------------------------------
    % 设置关节的运动范围 (PositionLimits)
    % --------------------------------------------------------------------
    % 关节限制的顺序应与 jointNames_arm 和 dhparams_table 表的顺序一致。
    % 单位为弧度。这些值应根据仿真需求或通用机械臂的典型范围设定。
    joint_limits_table = [ % [lower_limit, upper_limit] in radians
        -2*pi, 2*pi;         % 关节 1: shoulder_pan_joint
        -pi/2, pi/2;         % 关节 2: shoulder_lift_joint (例如：+/- 90度)
        -0.75*pi, 0.75*pi;   % 关节 3: elbow_joint (例如：+/- 135度)
        -2*pi, 2*pi;         % 关节 4: wrist_1_joint
        -2*pi, 2*pi;         % 关节 5: wrist_2_joint
        -2*pi, 2*pi          % 关节 6: wrist_3_joint
    ];
    
    % 遍历机器人模型中的活动连杆 (Bodies cell array) 并设置其关节的限制。
    % rigidBodyTree 中的 Bodies 列表包含了所有添加的连杆 (不包括基座)。
    % 其顺序与添加时的顺序一致。
    for i = 1:length(jointNames_arm) % 假设活动关节数量与jointNames_arm长度相同
        % robot.Bodies{i} 对应于按顺序添加的第 i 个活动连杆。
        % 这个连杆的 .Joint 属性就是其连接到父连杆的关节。
        robot.Bodies{i}.Joint.PositionLimits = joint_limits_table(i,:);
    end
    
    % --------------------------------------------------------------------
    % (可选) 显示构建好的机器人模型以供检查
    % --------------------------------------------------------------------
    figure; % 创建一个新的图形窗口
    % 'Frames','on'显示坐标系; 'Visuals','on'显示视觉模型(如果URDF定义了并被MATLAB正确解析)
    % homeConfiguration(robot) 返回所有关节角为0的配置 (如果theta_offset不为0，则实际角度为theta_offset)
    show(robot, homeConfiguration(robot), 'Frames', 'on', 'Visuals', 'on'); 
    hold on; % 保持当前图形，以便添加更多绘图元素
    % 在图形中绘制一个世界坐标系参考标记 (可选，用于对比)
    plotTransforms([0,0,0], eul2quat([0,0,0]), "FrameSize", 0.25, "FrameId", "MATLAB_World_Origin"); 
    axis equal; % 设置各轴比例相同，避免变形
    title('MATLAB中的机械臂模型 (D-H参数定义 - 尺寸已调整)'); % 图形标题
    xlabel('X 轴 (m)'); % X轴标签
    ylabel('Y 轴 (m)'); % Y轴标签
    zlabel('Z 轴 (m)'); % Z轴标签
    view(135, 25); % 设置三维图形的观察视角 (方位角135度，仰角25度)
    grid on; % 显示网格

    % 在命令行窗口输出提示信息
    disp('MATLAB机械臂仿真模型 (robot) 创建完成，尺寸已调整以适应约1米臂展。');
    disp('请确保URDF文件中对应的几何参数 (<xacro:property>) 和视觉/碰撞模型尺寸也已按比例更新。');
end

% --------------------------------------------------------------------
% 辅助函数：rt2tr (Rotation matrix and translation vector to homogeneous TRansform)
% --------------------------------------------------------------------
% 功能: 将3x3旋转矩阵R和3x1平移向量t组合成4x4齐次变换矩阵T。
% 输入:
%   R: 3x3 旋转矩阵
%   t: 3x1 或 1x3 平移向量
% 输出:
%   T: 4x4 齐次变换矩阵
function T = rt2tr(R, t)
    % 检查输入参数的维度是否正确
    if ~isequal(size(R), [3,3]) % 检查R是否为3x3矩阵
        error('输入错误: 旋转矩阵 R 必须是 3x3。'); % 抛出错误
    end
    if ~(numel(t) == 3) % 检查t是否包含3个元素
        error('输入错误: 平移向量 t 必须包含3个元素。'); % 抛出错误
    end
    
    T = eye(4); % 初始化T为4x4单位矩阵
    T(1:3, 1:3) = R; % 将旋转矩阵R赋给T的左上角3x3部分 (旋转部分)
    T(1:3, 4) = t(:); % 将平移向量t (通过t(:)确保为列向量) 赋给T的最后一列的前三行 (平移部分)
end
```

### 5.3 创建点云处理函数
为了处理从Gazebo接收的点云数据，我们需要创建一个点云处理函数。创建脚本文件process_point_cloud.m：
```matlab
function [obstacleStructs, processedPointCloudForVis] = process_point_cloud(pointCloudMsg, robot, varargin)
% process_point_cloud: 处理ROS点云消息，提取障碍物信息。
%
% 输入:
%   pointCloudMsg (sensor_msgs/PointCloud2): 来自ROS的原始点云消息。
%   robot (rigidBodyTree): 机械臂模型，用于潜在的自滤波（本版本未实现）。
%   varargin: 可选参数名值对，用于覆盖默认处理参数。支持的参数包括:
%             'EnableGraphics' (logical, default: true)
%             'GridStep' (double, default: 0.025) - 降采样网格大小 (米)
%             'MaxDistanceToPlane' (double, default: 0.03) - RANSAC地面移除: 点到平面最大距离 (米)
%             'ExpectedNormal' (1x3 double, default: [0,0,1]) - RANSAC地面移除: 期望法向量
%             'MaxAngularDeviation' (double, default: deg2rad(10)) - RANSAC地面移除: 最大角度偏差 (弧度)
%             'MinGroundPlanePoints' (double, default: 50) - RANSAC地面移除: 最小内点数
%             'UseRANSACFallback' (logical, default: true) - 是否在RANSAC失败时使用Z轴阈值法
%             'ZGroundThreshold' (double, default: 0.025) - Z轴阈值法: 地面高度阈值 (米)
%             'MinClusterDistance' (double, default: 0.06) - 欧几里得聚类: 最小聚类距离 (米)
%             'MinPointsPerCluster' (double, default: 10) - 欧几里得聚类: 每聚类最小点数
%             'MaxPointsPerCluster' (double, default: 25000) - 欧几里得聚类: 每聚类最大点数
%
% 输出:
%   obstacleStructs (cell array): 包含障碍物结构体 (含 .collisionObject 和 .centroid) 的单元数组。
%   processedPointCloudForVis (pointCloud): 处理后的点云对象，可用于外部可视化。

% --- 解析输入参数 ---
defaultParams = struct(...
    'EnableGraphics', true, ...
    'GridStep', 0.025, ...
    'MaxDistanceToPlane', 0.03, ...
    'ExpectedNormal', [0, 0, 1], ...
    'MaxAngularDeviation', deg2rad(10), ...
    'MinGroundPlanePoints', 50, ...
    'UseRANSACFallback', true, ...
    'ZGroundThreshold', 0.025, ...
    'MinClusterDistance', 0.06, ...
    'MinPointsPerCluster', 10, ...
    'MaxPointsPerCluster', 25000 ...
);

% 使用 inputParser 进行参数解析和验证
p = inputParser;
p.FunctionName = 'process_point_cloud'; % 用于错误消息

% 添加必需参数
addRequired(p, 'pointCloudMsg', @(x) isa(x, 'ros.msg.sensor_msgs.PointCloud2') || isstruct(x)); % 允许测试时传入结构体
addRequired(p, 'robot', @(x) isa(x, 'rigidBodyTree') || isempty(x)); % robot 参数在本函数当前实现中未直接使用，但保留接口

% 添加可选参数 (从 varargin 中解析)
fields = fieldnames(defaultParams);
for k=1:length(fields)
    addParameter(p, fields{k}, defaultParams.(fields{k}));
end

parse(p, pointCloudMsg, robot, varargin{:});

% 将解析后的参数赋给局部变量
enableGraphics        = p.Results.EnableGraphics;
gridStep              = p.Results.GridStep;
maxDistanceToPlane    = p.Results.MaxDistanceToPlane;
expectedNormal        = p.Results.ExpectedNormal;
maxAngularDeviation   = p.Results.MaxAngularDeviation;
minGroundPlanePoints  = p.Results.MinGroundPlanePoints;
useRANSACFallback     = p.Results.UseRANSACFallback;
zGroundThreshold      = p.Results.ZGroundThreshold;
minClusterDistance    = p.Results.MinClusterDistance;
minPointsPerCluster   = p.Results.MinPointsPerCluster;
maxPointsPerCluster   = p.Results.MaxPointsPerCluster;

% --- 函数主体开始 ---
disp('MATLAB (process_point_cloud): 开始处理点云数据...');

% 将ROS点云消息转换为MATLAB点云对象
try
    % 检查pointCloudMsg是否已经是MATLAB pointCloud对象（用于直接测试）
    if isa(pointCloudMsg, 'pointCloud')
        ptCloud = pointCloudMsg;
    else % 否则，假定是ROS消息
        xyzPoints = rosReadXYZ(pointCloudMsg); 
        if isempty(xyzPoints) || size(xyzPoints,1) < minPointsPerCluster % 至少需要足够点数形成一个最小簇
             warning('MATLAB (process_point_cloud): 点云数据为空或点数过少。');
             obstacleStructs = {};
             processedPointCloudForVis = pointCloud(zeros(0,3,'single')); 
             return;
        end
        ptCloud = pointCloud(xyzPoints);
    end
catch ME_read_pc
    warning(ME_read_pc.identifier, 'MATLAB (process_point_cloud): 无法读取或转换点云数据。错误: %s', ME_read_pc.message);
    obstacleStructs = {};
    processedPointCloudForVis = pointCloud(zeros(0,3,'single'));
    return;
end
disp(['MATLAB (process_point_cloud): 点云对象已准备好，包含 ', num2str(ptCloud.Count), ' 个点。']);

% 降采样以提高处理速度
ptCloudDownsampled = pcdownsample(ptCloud, 'gridAverage', gridStep);
disp(['MATLAB (process_point_cloud): 点云已降采样，网格大小: ', num2str(gridStep), ' 米。剩余点数: ', num2str(ptCloudDownsampled.Count)]);

% 移除离群点 (使用 pcdenoise 的默认参数，或者也可以参数化这些)
% 为保持与原版一致，此处不参数化pcdenoise内部参数
[ptCloudDenoised, ~] = pcdenoise(ptCloudDownsampled);
disp(['MATLAB (process_point_cloud): 点云已去噪。剩余点数: ', num2str(ptCloudDenoised.Count)]);

% 地面移除
ransacSuccess = false; 
nonGroundCloud = ptCloudDenoised; % 默认情况下，如果没有地面移除，则所有点都是非地面点

if ptCloudDenoised.Count > minGroundPlanePoints % 只有点数足够多时才尝试RANSAC
    disp('MATLAB (process_point_cloud): 尝试使用RANSAC拟合并移除地面平面...');
    try
        [planeModel, inlierIndices, outlierIndices] = pcfitplane(ptCloudDenoised, ...
                                                                 maxDistanceToPlane, ...
                                                                 expectedNormal, ...
                                                                 maxAngularDeviation);

        if ~isempty(planeModel) && numel(inlierIndices) >= minGroundPlanePoints
            ransacSuccess = true;
            disp(['MATLAB (process_point_cloud): RANSAC成功拟合地面平面。模型参数 (A,B,C,D): [', ...
                  num2str(planeModel.Parameters(1)), ', ', num2str(planeModel.Parameters(2)), ...
                  ', ', num2str(planeModel.Parameters(3)), ', ', num2str(planeModel.Parameters(4)), ']']);
            nonGroundCloud = select(ptCloudDenoised, outlierIndices);
            disp(['MATLAB (process_point_cloud): 已使用RANSAC移除地面点。剩余非地面点数: ', num2str(nonGroundCloud.Count)]);
        else
            if isempty(planeModel)
                warning('MATLAB (process_point_cloud): RANSAC未能拟合出平面模型。');
            else
                warning('MATLAB (process_point_cloud): RANSAC拟合的平面内点数 (%d) 少于最小要求的地面点数 (%d)。', numel(inlierIndices), minGroundPlanePoints);
            end
        end
    catch ME_ransac
        warning(ME_ransac.identifier, 'MATLAB (process_point_cloud): RANSAC平面拟合过程中发生错误: %s', ME_ransac.message);
    end
else
     disp('MATLAB (process_point_cloud): 点云数量不足以进行RANSAC地面拟合，跳过RANSAC。');
end

if ~ransacSuccess && useRANSACFallback
    disp('MATLAB (process_point_cloud): RANSAC地面移除失败或未执行，将回退到基于Z轴阈值的原始方法。');
    % 需要确保 nonGroundCloud 是基于 ptCloudDenoised 进行操作
    nonGroundIndices = ptCloudDenoised.Location(:,3) > zGroundThreshold;
    nonGroundCloud = select(ptCloudDenoised, nonGroundIndices);
    disp(['MATLAB (process_point_cloud): 已使用Z轴阈值法移除地面点。阈值 Z > ', num2str(zGroundThreshold), ' 米。剩余非地面点数: ', num2str(nonGroundCloud.Count)]);
elseif ~ransacSuccess && ~useRANSACFallback
    disp('MATLAB (process_point_cloud): RANSAC地面移除失败或未执行，且未启用回退策略。将使用去噪后的所有点进行聚类。');
    nonGroundCloud = ptCloudDenoised; % 使用去噪后的所有点
end

if isempty(nonGroundCloud.Location) || nonGroundCloud.Count < minPointsPerCluster
    warning('MATLAB (process_point_cloud): 移除地面点后，点云为空或点数过少以进行聚类。');
    obstacleStructs = {};
    processedPointCloudForVis = nonGroundCloud;
    if nonGroundCloud.Count == 0 
         processedPointCloudForVis = pointCloud(zeros(0,3,'single'));
    end
    return;
end

% 欧几里得聚类
[labels, numClusters] = pcsegdist(nonGroundCloud, minClusterDistance, ...
                                 [minPointsPerCluster, maxPointsPerCluster]);
disp(['MATLAB (process_point_cloud): 点云已分割成 ', num2str(numClusters), ' 个聚类。']);

obstacleStructs = cell(1, numClusters);
validObstacleCount = 0;

for i = 1:numClusters
    clusterIndices = (labels == i);
    clusterCloud = select(nonGroundCloud, clusterIndices);

    minPt = min(clusterCloud.Location, [], 1);
    maxPt = max(clusterCloud.Location, [], 1);
    dimensions = maxPt - minPt;

    if all(dimensions > 1e-3) % 最小维度阈值
        validObstacleCount = validObstacleCount + 1;
        obstacleBox = collisionBox(dimensions(1), dimensions(2), dimensions(3));
        centerPosition = (minPt + maxPt) / 2;
        obstacleBox.Pose = trvec2tform(centerPosition);

        tempStruct.collisionObject = obstacleBox;
        tempStruct.centroid = centerPosition(:)'; 
        obstacleStructs{validObstacleCount} = tempStruct;
    end
end

obstacleStructs = obstacleStructs(1:validObstacleCount);
disp(['MATLAB (process_point_cloud): 已创建 ', num2str(validObstacleCount), ' 个有效障碍物碰撞体。']);

processedPointCloudForVis = nonGroundCloud;
if nonGroundCloud.Count == 0
     processedPointCloudForVis = pointCloud(zeros(0,3,'single'));
end

if enableGraphics
    disp('MATLAB (process_point_cloud): 正在生成处理后点云的图形...');
    figureHandle = findobj('Type', 'Figure', 'Name', 'Point Cloud Processing Result');
    if isempty(figureHandle)
        figureHandle = figure('Name', 'Point Cloud Processing Result');
    else
        figure(figureHandle); % Bring to front
        clf(figureHandle);   % Clear figure
    end

    pcshow(processedPointCloudForVis); 
    hold on;
    for k_obj = 1:length(obstacleStructs)
        obs_s = obstacleStructs{k_obj}; % obs_s is a struct
        if isfield(obs_s, 'collisionObject') && isa(obs_s.collisionObject, 'collisionBox')
            show(obs_s.collisionObject, 'Parent', gca, 'FaceColor', 'r', 'FaceAlpha', 0.3, 'EdgeColor', 'k');
        end
    end
    hold off;
    title('处理后的点云数据及识别的障碍物 (AABB)');
    xlabel('X (米)'); ylabel('Y (米)'); zlabel('Z (米)');
    view(3); 
    axis equal;
    disp('MATLAB (process_point_cloud): 点云处理结果图形已显示/更新。');
else
    disp('MATLAB (process_point_cloud): 图形输出已禁用。');
end
disp('MATLAB (process_point_cloud): 点云处理完成。');
end
```
### 5.4 创建路径规划函数
接下来，我们创建一个路径规划函数，使用RRT算法在关节空间中规划避障路径。创建脚本文件plan_path.m：
```matlab
function [pathStates, success] = plan_path(robot, startConfigVec, goalConfigVec, obstacleObjectsCell, enableGraphics)
    % plan_path: 使用RRT算法在关节空间中规划避障路径。
    %
    % 输入:
    %   robot (rigidBodyTree): 机械臂模型。
    %   startConfigVec (double row vector): 机械臂的起始关节配置 (弧度)。
    %   goalConfigVec (double row vector): 机械臂的目标关节配置 (弧度)。
    %   obstacleObjectsCell (cell array): 包含场景中障碍物的 collision object (例如 collisionBox) 的单元数组。
    %   enableGraphics (logical): 可选参数。如果为 true (默认) 或未提供，则显示规划路径和障碍物。
    %                             如果为 false，则不执行任何绘图操作。
    %
    % 输出:
    %   pathStates (matrix or []): 规划成功时，返回一个矩阵，每行是一个路径点 (关节配置)。
    %                              规划失败时，返回空数组 []。
    %   success (logical): 指示路径规划是否成功。

    % 参数默认值处理
    if nargin < 5
        enableGraphics = true; % 如果未提供参数，则默认启用图形显示
    end
    if nargin < 4
        obstacleObjectsCell = {}; % 如果未提供障碍物，则默认为空
    end

    disp('MATLAB (plan_path): 开始路径规划...');

    % 创建基于RRT的路径规划器 (manipulatorRRT)
    % manipulatorRRT 构造函数可以直接接受机器人模型和障碍物单元数组
    planner = manipulatorRRT(robot, obstacleObjectsCell);
    disp('MATLAB (plan_path): manipulatorRRT规划器已创建。');

    % 设置规划器参数 (这些参数可能需要根据具体机器人和环境调整)
    planner.MaxConnectionDistance = 0.5;  % RRT树节点间的最大连接距离 (弧度)
    planner.MaxIterations = 5000;         % RRT算法的最大迭代次数
    planner.GoalReachedFcn = @(planner, q, qTarget) all(abs(wrapToPi(q - qTarget)) < 0.01); % 自定义目标到达判断，更严格
    % planner.GoalBias = 0.1; % 朝向目标的采样偏置概率
    % planner.ValidationDistance = 0.05; % 碰撞检测时路径段的采样间隔 (弧度)

    disp(['MATLAB (plan_path): 规划器参数设置 - MaxConnectionDistance: ', num2str(planner.MaxConnectionDistance), ...
          ', MaxIterations: ', num2str(planner.MaxIterations)]);

    % 执行路径规划
    % plan 函数需要起始和目标配置作为行向量
    disp('MATLAB (plan_path): 正在执行 plan() 函数...');
    tic; % 开始计时
    [pthObj, solnInfo] = plan(planner, startConfigVec(:)', goalConfigVec(:)'); % 确保是行向量
    planningDuration = toc; % 结束计时
    disp(['MATLAB (plan_path): plan() 函数执行完毕，耗时 ', num2str(planningDuration), ' 秒。']);

    pathStates = []; % 初始化输出

    % 检查规划结果
    if solnInfo.IsPathFound
        disp('MATLAB (plan_path): 路径规划成功！');
        success = true;

        % (可选) 平滑和插值路径
        % disp('MATLAB (plan_path): 正在平滑和插值路径...');
        % pthObj = shortenPath(pthObj); % （旧版函数，MATLAB R2021a+中可能无）
        % RRT*通常能找到较优路径，但 manipulatorRRT 是基础RRT，可能需要后处理
        % 可以使用 bsplinepolytraj 或其他方法进行平滑，但会增加复杂性。
        % 为保持与原指南逻辑接近，我们先直接使用RRT的输出点。
        % 如果需要更平滑轨迹，应在 generate_trajectory 中处理。
        
        % 提取路径点 (关节配置)
        pathStates = pthObj.PathStates; % R2023a onwards, .PathStates
        if isempty(pathStates) && ~isempty(pthObj.Configs) % Fallback for some versions
            pathStates = pthObj.Configs;
        end
        
        disp(['MATLAB (plan_path): 规划得到的路径包含 ', num2str(size(pathStates,1)), ' 个状态点。']);

        % 根据 enableGraphics 参数控制是否可视化路径
        if enableGraphics && ~isempty(pathStates)
            disp('MATLAB (plan_path): 正在生成规划路径的图形...');
            figure; % 仅在启用图形时创建新窗口
            
            % 显示起始配置的机器人
            show(robot, startConfigVec(:)', 'PreservePlot', false, 'Frames', 'off', 'Visuals', 'on');
            hold on;
            axis equal;
            title('规划的避障路径 (关节空间RRT)');
            xlabel('X (米)'); ylabel('Y (米)'); zlabel('Z (米)');
            view(135, 25); grid on;

            % 显示障碍物
            if ~isempty(obstacleObjectsCell)
                disp('MATLAB (plan_path): 正在绘制障碍物...');
                for i = 1:length(obstacleObjectsCell)
                    currentObs = obstacleObjectsCell{i};
                    if isa(currentObs, 'collisionMesh') % 网格类型障碍物
                         plot(currentObs, 'FaceColor', [0.8 0.2 0.2], 'FaceAlpha', 0.5);
                    elseif isa(currentObs, 'collisionBox') || isa(currentObs, 'collisionSphere') || isa(currentObs, 'collisionCylinder')
                         plot(currentObs, 'FaceColor', [0.8 0.2 0.2], 'FaceAlpha', 0.5); % 使用内置plot
                    end
                end
            end
            
            % 显示路径上的机器人动画 (每隔几个点显示一次以加快可视化)
            disp('MATLAB (plan_path): 正在动画演示路径...');
            pathPlotSkip = max(1, floor(size(pathStates,1)/20)); % 最多显示约20帧
            for i = 1:pathPlotSkip:size(pathStates, 1)
                show(robot, pathStates(i,:)', 'PreservePlot', false, 'Frames', 'off', 'Visuals', 'on');
                drawnow; % 刷新图形
                % pause(0.01); % 短暂暂停以观察
            end
            % 显示最终配置
            show(robot, pathStates(end,:)', 'PreservePlot', false, 'Frames', 'off', 'Visuals', 'on');
            hold off;
            disp('MATLAB (plan_path): 路径可视化完成。');
        elseif enableGraphics && isempty(pathStates)
            disp('MATLAB (plan_path): 路径规划成功但路径状态为空，无法可视化。');
        else
            disp('MATLAB (plan_path): 图形输出已禁用。');
        end
    else
        disp('MATLAB (plan_path): 路径规划失败。');
        disp(['MATLAB (plan_path): 失败原因/信息: ', solnInfo.Status]); % manipulatorRRT 的 solnInfo.Status 可能不直接提供文本原因
        success = false;
        pathStates = []; % 确保失败时返回空
    end
end
```
### 5.5 创建轨迹生成函数
为了生成平滑的轨迹，我们创建一个轨迹生成函数。创建脚本文件generate_trajectory.m：
```matlab
function trajMsg = generate_trajectory(path, jointNames)
    % 检查输入参数
    if isempty(path) || isempty(path.States)
        error('路径为空，无法生成轨迹');
    end
    
    % 获取路径点
    waypoints = path.States';  % 转置为 numJoints x numPoints
    
    % 生成梯形速度轨迹
    numSamples = max(100, size(waypoints, 2) * 5);  % 轨迹点数量
    [q, qd, qdd, tvec] = trapveltraj(waypoints, numSamples);
    
    % 创建轨迹消息
    trajMsg = rosmessage('trajectory_msgs/JointTrajectory');
    trajMsg.JointNames = jointNames;
    
    % 填充轨迹点
    for i = 1:numSamples
        point = rosmessage('trajectory_msgs/JointTrajectoryPoint');
        point.Positions = q(:,i)';
        point.Velocities = qd(:,i)';
        point.Accelerations = qdd(:,i)';
        point.TimeFromStart = rosduration(tvec(i));
        trajMsg.Points(i) = point;
    end
    
    disp(['生成了包含 ', num2str(numSamples), ' 个点的轨迹']);
end
```

### 5.6 创建机械臂控制函数
接下来，我们创建一个函数来控制机械臂执行规划的轨迹。创建脚本文件control_arm.m：
```matlab
function control_arm(trajMsg)
    % 创建轨迹发布者
    trajPub = rospublisher('/custom_arm/arm_controller/command', 'trajectory_msgs/JointTrajectory');
    
    % 发送轨迹命令
    disp('发送轨迹命令到机械臂...');
    send(trajPub, trajMsg);
    
    % 等待轨迹执行完成
    % 计算轨迹执行时间
    if ~isempty(trajMsg.Points)
        executionTime = trajMsg.Points(end).TimeFromStart.Sec + ...
                        trajMsg.Points(end).TimeFromStart.Nsec * 1e-9;
        disp(['等待轨迹执行完成，预计时间: ', num2str(executionTime), ' 秒']);
        pause(executionTime + 1);  % 额外等待1秒确保执行完成
        disp('轨迹执行完成');
    else
        warning('轨迹消息中没有点');
    end
end
```

### 5.7 创建主动避障循环
最后，我们创建一个主函数，实现完整的主动避障循环。创建脚本文件arm_obstacle_avoidance.m：
```matlab
function arm_obstacle_avoidance()
    % arm_obstacle_avoidance: 使用ROS服务进行基本避障任务。
    % 该脚本通过调用 /request_robot_plan 服务来获取路径规划。

    disp('启动基本避障任务 (基于ROS服务)...');

    % 1. 初始化与ROS的连接和基本设置
    ros_master_uri = connect_to_ros();
    if isempty(ros_master_uri)
        error('arm_obstacle_avoidance: 无法连接到ROS主节点。请确保roscore、Gazebo仿真、planning_service.py 和 matlab_ros_planner.m 正在运行。');
    end

    robot = create_robot_model(false); % false表示不显示图形，避免重复

    jointNames = cell(1, numel(robot.homeConfiguration));
    for i = 1:numel(robot.homeConfiguration)
        jointNames{i} = robot.Bodies{i}.Joint.Name;
    end

    jointStateSub = rossubscriber('/custom_arm/joint_states', 'sensor_msgs/JointState');
    pointCloudSub = rossubscriber('/camera/depth/points', 'sensor_msgs/PointCloud2', 'BufferSize', 1);

    disp('arm_obstacle_avoidance: 正在创建到 /request_robot_plan 服务的客户端...');
    try
        planClient = rossvcclient('/request_robot_plan', 'arm_obstacle_avoidance/RequestPlan', 'Timeout', 30); % 增加服务调用超时
        waitForServer(planClient,'Timeout',15); % 等待服务实际可用
        disp('arm_obstacle_avoidance: 服务客户端已成功创建并连接。');
    catch ME
        disp(ME);
        error('arm_obstacle_avoidance: 创建服务客户端 /request_robot_plan 失败。请检查ROS服务和MATLAB规划节点状态。');
    end

    % 2. 获取初始状态
    disp('arm_obstacle_avoidance: 等待接收初始关节状态...');
    initialJointStateMsg = receive(jointStateSub, 15); % 增加等待时间
    if isempty(initialJointStateMsg)
        error('arm_obstacle_avoidance: 未能接收到初始关节状态。请检查 /custom_arm/joint_states 话题。');
    end

    currentJointValues = zeros(1, length(jointNames));
    currentConfigStruct = robot.homeConfiguration; % 用于计算当前EE位姿
    for i = 1:length(jointNames)
        jointName = jointNames{i};
        [isMember, idx] = ismember(jointName, initialJointStateMsg.Name);
        if isMember
            currentJointValues(i) = initialJointStateMsg.Position(idx);
            currentConfigStruct(i).JointPosition = initialJointStateMsg.Position(idx);
        else
            warning('arm_obstacle_avoidance: 关节 %s 在接收到的JointState消息中未找到。将使用模型默认值。', jointName);
            currentJointValues(i) = currentConfigStruct(i).JointPosition; % 使用默认值
        end
    end
    disp(['arm_obstacle_avoidance: 初始关节角度: [', num2str(currentJointValues), ']']);

    currentEeTform_matrix = getTransform(robot, currentConfigStruct, 'tool0');
    current_ee_pos_srv = tform2trvec(currentEeTform_matrix);
    current_ee_quat_srv = tform2quat(currentEeTform_matrix);

    % 3. 定义目标位姿
    goalPosition_target = [0.7, 0.3, 0.2];  % [x, y, z] 米
    goalOrientation_target_quat = [1, 0, 0, 0]; % W, X, Y, Z (默认姿态，根据IK调整)

    % 4. 主尝试循环
    maxAttempts = 3;
    attempt = 1;
    reachedGoal = false;

    while attempt <= maxAttempts && ~reachedGoal
        disp(['arm_obstacle_avoidance: 尝试 ', num2str(attempt), '/', num2str(maxAttempts)]);

        % 4.1 获取最新的点云数据
        disp('arm_obstacle_avoidance: 获取最新的点云数据...');
        latestPointCloudMsg = receive(pointCloudSub, 10); 
        if isempty(latestPointCloudMsg)
            warning('arm_obstacle_avoidance: 未能获取点云数据，跳过此次尝试。');
            attempt = attempt + 1;
            pause(1);
            continue;
        end

        % 4.2 构建服务请求 (完整规划)
        planReq = rosmessage(planClient);
        planReq.ValidateEnvironmentOnly = false; % 请求完整规划
        planReq.CurrentObstacleMap = latestPointCloudMsg;
        planReq.CurrentJointValues = currentJointValues;

        planReq.CurrentEePose = rosmessage('geometry_msgs/PoseStamped');
        planReq.CurrentEePose.Header.FrameId = 'base_link'; 
        planReq.CurrentEePose.Header.Stamp = rostime('now');
        planReq.CurrentEePose.Pose.Position.X = current_ee_pos_srv(1);
        planReq.CurrentEePose.Pose.Position.Y = current_ee_pos_srv(2);
        planReq.CurrentEePose.Pose.Position.Z = current_ee_pos_srv(3);
        planReq.CurrentEePose.Pose.Orientation.W = current_ee_quat_srv(1);
        planReq.CurrentEePose.Pose.Orientation.X = current_ee_quat_srv(2);
        planReq.CurrentEePose.Pose.Orientation.Y = current_ee_quat_srv(3);
        planReq.CurrentEePose.Pose.Orientation.Z = current_ee_quat_srv(4);

        planReq.GoalEePose = rosmessage('geometry_msgs/PoseStamped');
        planReq.GoalEePose.Header.FrameId = 'base_link'; 
        planReq.GoalEePose.Header.Stamp = rostime('now');
        planReq.GoalEePose.Pose.Position.X = goalPosition_target(1);
        planReq.GoalEePose.Pose.Position.Y = goalPosition_target(2);
        planReq.GoalEePose.Pose.Position.Z = goalPosition_target(3);
        planReq.GoalEePose.Pose.Orientation.W = goalOrientation_target_quat(1);
        planReq.GoalEePose.Pose.Orientation.X = goalOrientation_target_quat(2);
        planReq.GoalEePose.Pose.Orientation.Y = goalOrientation_target_quat(3);
        planReq.GoalEePose.Pose.Orientation.Z = goalOrientation_target_quat(4);

        % 4.3 调用服务
        disp('arm_obstacle_avoidance: 发送完整规划请求至服务...');
        try
            planResp = call(planClient, planReq, 'Timeout', 75); % 规划可能非常耗时
        catch ME_call
            disp(ME_call);
            warning('arm_obstacle_avoidance: 调用规划服务失败或超时。');
            attempt = attempt + 1;
            pause(2); 
            continue;
        end

        % 4.4 处理服务响应
        if ~isempty(planResp) && planResp.Success
            disp('arm_obstacle_avoidance: 规划服务成功返回路径。');
            trajMsg = planResp.PlannedTrajectory;

            if isempty(trajMsg.JointNames) || isempty(trajMsg.Points)
                warning('arm_obstacle_avoidance: 服务返回的轨迹为空，无法执行。');
                attempt = attempt + 1;
                continue;
            end

            % 4.5 执行轨迹
            disp('arm_obstacle_avoidance: 控制机械臂执行轨迹...');
            control_arm(trajMsg); % control_arm 函数来自章节 5.6

            % 4.6 检查是否到达目标
            disp('arm_obstacle_avoidance: 等待轨迹执行完毕后检查状态...');
            % control_arm 内部有 pause，这里可以再稍等一下确保状态更新
            pause(1.5); 
            finalJointStateMsg = receive(jointStateSub, 10);
            if isempty(finalJointStateMsg)
                warning('arm_obstacle_avoidance: 未能接收到最终关节状态。');
            else
                % 更新 currentJointValues 和 currentConfigStruct 以获取当前EE位姿
                for i = 1:length(jointNames)
                    jointName = jointNames{i};
                     [isMember, idx] = ismember(jointName, finalJointStateMsg.Name);
                    if isMember
                        currentJointValues(i) = finalJointStateMsg.Position(idx);
                        currentConfigStruct(i).JointPosition = finalJointStateMsg.Position(idx);
                    end
                end

                currentEETransform_check = getTransform(robot, currentConfigStruct, 'tool0');
                currentPosition_check = tform2trvec(currentEETransform_check);
                distanceToGoal = norm(currentPosition_check - goalPosition_target);
                disp(['arm_obstacle_avoidance: 当前末端位置: [', num2str(currentPosition_check), '], 距离目标: ', num2str(distanceToGoal), ' 米']);

                goal_tolerance = 0.08; % 目标容差8cm
                if distanceToGoal < goal_tolerance
                    disp(['arm_obstacle_avoidance: 成功到达目标位置 (容差: ', num2str(goal_tolerance), 'm)!']);
                    reachedGoal = true;
                    break; 
                else
                    disp('arm_obstacle_avoidance: 尚未到达目标位置。');
                    % 更新当前EE位姿，为下一次尝试做准备（如果不是因为规划本身失败）
                    current_ee_pos_srv = currentPosition_check;
                    current_ee_quat_srv = tform2quat(currentEETransform_check);
                end
            end
        else % 服务调用不成功或规划本身失败
            if ~isempty(planResp)
                disp(['arm_obstacle_avoidance: 规划失败，服务消息: ', planResp.Message]);
            else
                disp('arm_obstacle_avoidance: 规划服务未返回有效响应。');
            end
        end

        attempt = attempt + 1;
        if ~reachedGoal
            disp('arm_obstacle_avoidance: 等待2秒后重试...');
            pause(2);
        end
    end 

    if ~reachedGoal
        disp('arm_obstacle_avoidance: 达到最大尝试次数，未能到达目标位置。');
    end

    disp('arm_obstacle_avoidance: 基本避障任务结束。');
    % rosshutdown; % 由 main.m 或用户决定何时关闭
end
```

### 5.8 创建动态避障功能
为了实现主动避障，我们需要创建一个函数来监测环境变化并在必要时重新规划路径。创建脚本文件active_obstacle_avoidance.m：
```matlab
function active_obstacle_avoidance()
    % active_obstacle_avoidance: 实现主动避障，通过ROS服务进行规划、环境验证和重规划。

    disp('启动主动避障任务 (基于ROS服务)...');

    % 1. 初始化
    ros_master_uri = connect_to_ros();
    if isempty(ros_master_uri)
        error('active_obstacle_avoidance: 无法连接到ROS。确保roscore, Gazebo, planning_service.py, matlab_ros_planner.m 运行中。');
    end

    robot = create_robot_model(false); 

    jointNames = cell(1, numel(robot.homeConfiguration));
    for i = 1:numel(robot.homeConfiguration)
        jointNames{i} = robot.Bodies{i}.Joint.Name;
    end

    jointStateSub = rossubscriber('/custom_arm/joint_states', 'sensor_msgs/JointState');
    % 调整 BufferSize 和 monitoringRate
    % 增加BufferSize以减少消息丢失的可能性
    pointCloudSub = rossubscriber('/camera/depth/points', 'sensor_msgs/PointCloud2', 'BufferSize', 5);
    trajPub = rospublisher('/custom_arm/arm_controller/command', 'trajectory_msgs/JointTrajectory');

    disp('active_obstacle_avoidance: 正在创建到 /custom_arm/arm_controller/state 的订阅器...');
    try
        armControllerStateSub = rossubscriber('/custom_arm/arm_controller/state', 'control_msgs/JointTrajectoryControllerState', 'BufferSize', 5);
        disp('active_obstacle_avoidance: 控制器状态订阅器已创建。');
    catch ME_state_sub
        disp(ME_state_sub);
        error('active_obstacle_avoidance: 创建控制器状态订阅器 /custom_arm/arm_controller/state 失败。请检查控制器是否发布此话题。');
    end

    disp('active_obstacle_avoidance: 正在创建 /target_pose 交互式目标点订阅器...');
    try
        targetSub = rossubscriber('/target_pose', 'geometry_msgs/PoseStamped', 'BufferSize', 1);
        disp('active_obstacle_avoidance: /target_pose 订阅器已创建。');
    catch ME_target_sub
        disp(ME_target_sub);
        warning('active_obstacle_avoidance: 创建 /target_pose 订阅器失败。交互式目标点功能将不可用。');
        targetSub = []; % 将 targetSub 置为空，以便后续代码可以检查
    end
    
    disp('active_obstacle_avoidance: 正在创建到 /request_robot_plan 服务的客户端...');
    
    try
        planClient = rossvcclient('/request_robot_plan', 'arm_obstacle_avoidance/RequestPlan', 'Timeout', 30);
        waitForServer(planClient,'Timeout',15);
        disp('active_obstacle_avoidance: 服务客户端已成功创建并连接。');
    catch ME
        disp(ME);
        error('active_obstacle_avoidance: 创建服务客户端失败。');
    end

    disp('active_obstacle_avoidance: 获取初始手臂状态...');
    % 使用 robot.homeConfiguration 作为 prevConfigStruct 的初始值
    [currentJointValues, currentConfigStruct, currentEePoseStruct, initStateSuccess] = ...
        get_current_arm_state_active(jointStateSub, robot, jointNames, robot.homeConfiguration);

    if ~initStateSuccess
        error('active_obstacle_avoidance: 未能成功获取初始手臂状态。请检查ROS话题和机器人状态。');
    end
    current_ee_pos_for_srv = currentEePoseStruct.position;
    current_ee_quat_for_srv = currentEePoseStruct.orientation_quat;
    disp(['active_obstacle_avoidance: 初始关节角度: [', num2str(currentJointValues), ']']);
    disp(['active_obstacle_avoidance: 初始末端执行器位置: [', num2str(current_ee_pos_for_srv), ']']);

    goalPosition_target = [0.7, 0.3, 0.2];
    goalOrientation_target_quat = [1, 0, 0, 0]; 

    monitoringRate = 5;  % Hz (环境监测频率)
    goal_tolerance = 0.08; % 8cm
    % 解决方案 2: 监控关节速度所需的参数
    stop_velocity_threshold_rad_s = 0.02; % 关节速度低于此值视为停止 (rad/s)
    consecutive_stopped_checks_needed = 5; % 需要连续检测到低速的次数
    max_wait_time_for_stop_s = 3.0;    % 等待机械臂停止的最大时间 (秒)

    % 解决方案 1: 轨迹执行超时参数
    trajectory_execution_timeout_factor = 1.8; % 轨迹执行超时因子 (理论时间 * 此因子)
    trajectory_min_execution_timeout_s = 5.0; % 任何轨迹的最小执行超时时间 (秒)

    maxPlannerAttempts = 10; % 总的规划尝试（包括重规划）
    plannerAttempt = 1;
    reachedGoal = false;
    pathExecutionInterrupted = false; % 标记路径执行是否因环境变化而中断

    % 2. 主动避障循环
    while ~reachedGoal && plannerAttempt <= maxPlannerAttempts
    	% 检查并处理来自RViz的交互式目标点
        if ~isempty(targetSub) % 仅当订阅器成功创建时才尝试接收
            targetMsg = receive(targetSub, 0.01); % 非阻塞接收, 短超时 (0.01秒)
            if ~isempty(targetMsg)
                newGoalPosition = [targetMsg.Pose.Position.X, ...
                                   targetMsg.Pose.Position.Y, ...
                                   targetMsg.Pose.Position.Z];
                newGoalOrientationQuat = [targetMsg.Pose.Orientation.W, ...
                                          targetMsg.Pose.Orientation.X, ...
                                          targetMsg.Pose.Orientation.Y, ...
                                          targetMsg.Pose.Orientation.Z];

                % 检查目标是否真的改变了，避免不必要的日志刷新
                if ~isequal(goalPosition_target, newGoalPosition) || ~isequal(goalOrientation_target_quat, newGoalOrientationQuat)
                    goalPosition_target = newGoalPosition;
                    goalOrientation_target_quat = newGoalOrientationQuat;
                    disp(['active_obstacle_avoidance: 收到新的交互式目标点: Pos=[', num2str(goalPosition_target), ...
                          '], Quat=[', num2str(goalOrientation_target_quat), ']']);
                    % 当收到新目标时，可以考虑重置规划尝试计数器或采取其他逻辑
                    % 例如，如果机器人正在移动，可能需要先发送停止指令
                    % 此处简单更新目标，下一次规划将使用新目标
                end
            end
        end
        disp(['===== active_obstacle_avoidance: 规划尝试 ', num2str(plannerAttempt), '/', num2str(maxPlannerAttempts), ' =====']);
        pathExecutionInterrupted = false; % 重置中断标记

        % 2.1 获取当前状态用于规划
        disp('active_obstacle_avoidance: 获取当前点云和关节状态用于规划...');
        latestPointCloudForPlanning = receive(pointCloudSub, 10);
        if isempty(latestPointCloudForPlanning)
            warning('active_obstacle_avoidance: 未能获取点云数据进行规划，跳过此次尝试。');
            plannerAttempt = plannerAttempt + 1; pause(1); continue;
        end

        % 使用 currentConfigStruct (它在循环开始时或上次成功更新后被设置) 作为 prevConfigStruct
        [currentJointValues, currentConfigStruct, currentEePoseStruct, planningStateSuccess] = ...
            get_current_arm_state_active(jointStateSub, robot, jointNames, currentConfigStruct);

        if ~planningStateSuccess
            warning('active_obstacle_avoidance: 未能成功获取用于规划的当前手臂状态，可能使用上次的旧值。');
            % currentJointValues, currentConfigStruct, currentEePoseStruct 仍然包含来自 get_current_arm_state_active 的（可能是旧的）值
        end
        current_ee_pos_for_srv = currentEePoseStruct.position;
        current_ee_quat_for_srv = currentEePoseStruct.orientation_quat;
        disp(['active_obstacle_avoidance: 用于规划的关节角度: [', num2str(currentJointValues), ']']);
        disp(['active_obstacle_avoidance: 用于规划的末端执行器位置: [', num2str(current_ee_pos_for_srv), ']']);

        % 2.2 请求完整路径规划
        planReqFull = rosmessage(planClient);
        planReqFull.ValidateEnvironmentOnly = false;
        planReqFull.CurrentObstacleMap = latestPointCloudForPlanning;
        planReqFull.CurrentJointValues = currentJointValues;
        planReqFull.CurrentEePose = populate_pose_stamped_msg_active('base_link', current_ee_pos_for_srv, current_ee_quat_for_srv);
        planReqFull.GoalEePose = populate_pose_stamped_msg_active('base_link', goalPosition_target, goalOrientation_target_quat);


        disp('active_obstacle_avoidance: 发送完整规划请求...');
        try
            planRespFull = call(planClient, planReqFull, 'Timeout', 75);
        catch ME_call_full
            disp(ME_call_full);
            warning('active_obstacle_avoidance: 调用完整规划服务失败或超时。');
            plannerAttempt = plannerAttempt + 1; pause(2); continue;
        end

        if isempty(planRespFull) || ~planRespFull.Success || isempty(planRespFull.PlannedTrajectory.JointNames) || isempty(planRespFull.PlannedTrajectory.Points)
            if ~isempty(planRespFull)
                disp(['active_obstacle_avoidance: 完整规划失败，服务消息: ', planRespFull.Message]);
            else
                disp('active_obstacle_avoidance: 完整规划服务未返回有效轨迹。');
            end
            plannerAttempt = plannerAttempt + 1; pause(1); continue;
        end

        disp('active_obstacle_avoidance: 完整规划成功，获取到轨迹。');
        activeTrajMsg = planRespFull.PlannedTrajectory;

        % 2.3 执行轨迹并进行环境监测 (基于控制器反馈和超时)
        disp('active_obstacle_avoidance: 开始执行轨迹并监测环境...');
        send(trajPub, activeTrajMsg); % 发送轨迹给控制器

        theoreticalTrajectoryExecutionTime_s = 0;
        if ~isempty(activeTrajMsg.Points)
             theoreticalTrajectoryExecutionTime_s = activeTrajMsg.Points(end).TimeFromStart.Sec + activeTrajMsg.Points(end).TimeFromStart.Nsec*1e-9;
        end
        % 计算实际的执行超时时间
        effectiveTrajectoryTimeout_s = max(trajectory_min_execution_timeout_s, theoreticalTrajectoryExecutionTime_s * trajectory_execution_timeout_factor);
        disp(['active_obstacle_avoidance: 轨迹理论执行时间: ', num2str(theoreticalTrajectoryExecutionTime_s), 's. 监测超时设为: ', num2str(effectiveTrajectoryTimeout_s), 's']);

        trajectoryMonitoringStartTime = tic;
        lastControllerStatusTime = rostime('now'); % 用于判断控制器状态是否在更新

        pathExecutionInterrupted = false; % 确保在此处定义或重置

        while toc(trajectoryMonitoringStartTime) < effectiveTrajectoryTimeout_s
            % --- 检查控制器状态 ---
            controllerStateMsg = armControllerStateSub.LatestMessage; % 非阻塞获取最新状态
            
            trajectoryDone = false; 
            controllerOperational = true;

            if ~isempty(controllerStateMsg)
                % --- 防御性编程：检查控制器状态消息结构 ---
                expectedFields = struct(...
                    'Header', {{'Stamp'}}, ...
                    'Error', {{'Positions'}}, ...
                    'Actual', {{'Velocities', 'Positions'}}, ...
                    'GoalId', {{'Id'}} ...
                );
                
                missingInfo = {}; % 用于存储缺失信息的单元格数组

                if ~isprop(controllerStateMsg, 'Header')
                    missingInfo{end+1} = 'Header';
                elseif ~isprop(controllerStateMsg.Header, 'Stamp')
                    missingInfo{end+1} = 'Header.Stamp';
                end

                if ~isprop(controllerStateMsg, 'Error')
                    missingInfo{end+1} = 'Error';
                elseif ~isprop(controllerStateMsg.Error, 'Positions')
                    missingInfo{end+1} = 'Error.Positions';
                end

                if ~isprop(controllerStateMsg, 'Actual')
                    missingInfo{end+1} = 'Actual';
                else
                    if ~isprop(controllerStateMsg.Actual, 'Velocities')
                        missingInfo{end+1} = 'Actual.Velocities';
                    end
                    if ~isprop(controllerStateMsg.Actual, 'Positions')
                        missingInfo{end+1} = 'Actual.Positions';
                    end
                end
                
                if ~isprop(controllerStateMsg, 'GoalId')
                    missingInfo{end+1} = 'GoalId';
                elseif ~isprop(controllerStateMsg.GoalId, 'Id')
                    missingInfo{end+1} = 'GoalId.Id';
                end

                if ~isempty(missingInfo)
                    errMsg = sprintf('控制器状态消息结构与预期不符。缺失或结构错误的字段: %s。', strjoin(missingInfo, ', '));
                    disp(['错误: active_obstacle_avoidance: [控制器状态] ' errMsg]);
                    error('程序中止: %s', errMsg);
                end
                % --- 消息结构检查完毕 ---

                lastControllerStatusTime = controllerStateMsg.Header.Stamp; % 此处安全，因为 Header.Stamp 已确认存在

                % 判断轨迹是否仍在执行 (基于已验证的字段)：
                if ~isempty(controllerStateMsg.Error.Positions) && ~isempty(controllerStateMsg.Actual.Velocities)
                    joint_errors = abs(controllerStateMsg.Error.Positions);
                    joint_velocities = abs(controllerStateMsg.Actual.Velocities);
                    
                    if all(joint_errors < 0.05) && all(joint_velocities < stop_velocity_threshold_rad_s)
                        if ~isempty(activeTrajMsg.Points)
                            lastTrajPointPositions = activeTrajMsg.Points(end).Positions;
                            currentActualPositions = controllerStateMsg.Actual.Positions;
                            if length(lastTrajPointPositions) == length(currentActualPositions)
                                diff_to_last_point = abs(currentActualPositions - lastTrajPointPositions);
                                if all(diff_to_last_point < goal_tolerance)
                                    disp('active_obstacle_avoidance: [控制器状态] 接近轨迹终点且稳定。');
                                    trajectoryDone = true; 
                                end
                            end
                        else
                             trajectoryDone = true; 
                        end
                    end
                else
                    disp('active_obstacle_avoidance: [控制器状态] Error.Positions 或 Actual.Velocities 为空，可能控制器行为特殊或轨迹刚开始。');
                end
                
                % 检查是否有活动的goal_id (更可靠的判断方式)
                % isprop(controllerStateMsg, 'GoalId') && isprop(controllerStateMsg.GoalId, 'Id') 之前已校验过
                if ~isempty(controllerStateMsg.GoalId.Id)
                    trajectoryDone = false; 
                    disp('active_obstacle_avoidance: [控制器状态] 控制器有活动的Goal ID，仍在执行。');
                elseif isempty(controllerStateMsg.GoalId.Id) && ~trajectoryDone
                    disp('active_obstacle_avoidance: [控制器状态] 控制器无活动Goal ID。');
                    trajectoryDone = true; % 假设完成或中止
                end

            else % 如果长时间未收到控制器状态消息
                 % 确保 lastControllerStatusTime 在此作用域已定义，如果之前从未收到过 controllerStateMsg，
                 % lastControllerStatusTime 可能未初始化。在循环开始前初始化 lastControllerStatusTime = rostime('now');
                if (rostime('now') - lastControllerStatusTime) > rosduration(2.0) 
                    warning('active_obstacle_avoidance: [控制器状态] 长时间未收到控制器状态更新。');
                    controllerOperational = false;
                    trajectoryDone = true; 
                end
            end

            if trajectoryDone || ~controllerOperational
                if controllerOperational
                    disp('active_obstacle_avoidance: 控制器报告轨迹执行完毕或稳定。');
                else
                    disp('active_obstacle_avoidance: 控制器操作异常或长时间无状态更新。');
                end
                break; % 跳出监测循环
            end

            % --- 环境监测逻辑 (在轨迹仍在执行时) ---
            pause(1/monitoringRate); % 控制监测频率

            disp('active_obstacle_avoidance: [监测中] 获取最新点云进行验证...');
            latestPointCloudForValidation = receive(pointCloudSub, 1.0/monitoringRate * 0.8); 

            if ~isempty(latestPointCloudForValidation)
                valReq = rosmessage(planClient);
                valReq.ValidateEnvironmentOnly = true;
                valReq.CurrentObstacleMap = latestPointCloudForValidation;
                
                % --- 获取并校验用于环境验证的当前关节状态 ---
                disp('active_obstacle_avoidance: [监测中] 获取用于验证的当前关节状态...');
                % 使用 currentConfigStruct (它在循环开始时或上次成功更新后被设置) 作为 prevConfigStruct
                [tempCurrentJointValuesVal, tempCurrentConfigStructVal, tempEePoseStructVal, validationStateSuccess] = ...
                    get_current_arm_state_active(jointStateSub, robot, jointNames, currentConfigStruct);

                if ~validationStateSuccess
                    warning('active_obstacle_avoidance: [监测中] 未能成功获取用于环境验证的当前手臂状态。跳过此次验证。');
                    % 在这里决定是 continue; 跳过本次监测循环，还是允许使用可能不完全准确的旧值。
                    % 为安全起见，如果状态获取失败，最好跳过验证或发出更严重的警告。
                    % 此处选择继续，但后续代码需要知道 tempEePoseStructVal 可能不是最新的。
                    % （或者，可以在 get_current_arm_state_active 内部决定是否 error out）
                else
                    disp('active_obstacle_avoidance: [监测中] 成功获取用于验证的手臂状态。');
                end
                % tempCurrentJointValuesVal, tempEePoseStructVal 现在包含了最新的（或尽力获取的）状态

                valReq.CurrentJointValues = tempCurrentJointValuesVal; % 使用从辅助函数获取的值

                % 使用辅助函数填充 CurrentEePose
                valReq.CurrentEePose = populate_pose_stamped_msg_active('base_link', tempEePoseStructVal.position, tempEePoseStructVal.orientation_quat);

                % GoalEePose 保持不变 (使用原规划的目标)
                valReq.GoalEePose = planReqFull.GoalEePose;

                disp('active_obstacle_avoidance: [监测中] 发送环境验证请求...');
                try
                    valResp = call(planClient, valReq, 'Timeout', 20); 
                catch ME_call_val
                    disp(ME_call_val);
                    warning('active_obstacle_avoidance: [监测中] 调用环境验证服务失败或超时。继续执行当前轨迹。');
                    continue; 
                end

                if ~isempty(valResp) && valResp.Success
                    if valResp.EnvironmentHasChangedSignificantly
                        disp('active_obstacle_avoidance: [监测中] 检测到环境显著变化！正在停止机械臂...');
                        pathExecutionInterrupted = true;
                        stopTrajMsg = create_stop_trajectory_active(jointStateSub, jointNames, robot, currentConfigStruct);
						send(trajPub, stopTrajMsg);
                        
                        disp('active_obstacle_avoidance: 等待机械臂完全停止...');
                        consecutive_stopped_count = 0;
                        stop_check_begin_time = tic;
                        arm_confirmed_stopped = false;

                        while toc(stop_check_begin_time) < max_wait_time_for_stop_s
                            currentStopCheckStateMsg = receive(jointStateSub, 0.05); 
                            if ~isempty(currentStopCheckStateMsg) && isprop(currentStopCheckStateMsg, 'Velocity') && ~isempty(currentStopCheckStateMsg.Velocity) && ...
                               isprop(currentStopCheckStateMsg, 'Name') % 确保 Name 字段存在
                                velocities_abs = abs(currentStopCheckStateMsg.Velocity); 
                                relevant_velocities_low = true;
                                for j_idx = 1:length(jointNames)
                                     [isMemberStop, stop_idx] = ismember(jointNames{j_idx}, currentStopCheckStateMsg.Name);
                                     if isMemberStop && stop_idx > 0 && stop_idx <= length(velocities_abs)
                                         if velocities_abs(stop_idx) > stop_velocity_threshold_rad_s
                                             relevant_velocities_low = false;
                                             break;
                                         end
                                     else 
                                         relevant_velocities_low = false;
                                         break;
                                     end
                                end

                                if relevant_velocities_low
                                    consecutive_stopped_count = consecutive_stopped_count + 1;
                                    if consecutive_stopped_count >= consecutive_stopped_checks_needed
                                        disp('active_obstacle_avoidance: 机械臂已确认速度停止。');
                                        arm_confirmed_stopped = true;
                                        break; 
                                    end
                                else
                                    consecutive_stopped_count = 0; 
                                end
                            else
                                consecutive_stopped_count = 0; 
                                if isempty(currentStopCheckStateMsg)
                                    disp('active_obstacle_avoidance: [停止检查] 未收到关节状态。');
                                elseif ~isprop(currentStopCheckStateMsg, 'Velocity') || isempty(currentStopCheckStateMsg.Velocity)
                                     disp('active_obstacle_avoidance: [停止检查] 关节状态消息缺少速度信息。');
                                elseif ~isprop(currentStopCheckStateMsg, 'Name')
                                     disp('active_obstacle_avoidance: [停止检查] 关节状态消息缺少名称信息。');
                                end
                            end
                            pause(0.1); 
                        end

                        if ~arm_confirmed_stopped
                            warning('active_obstacle_avoidance: 等待机械臂速度停止超时或未能确认。');
                        end
                        pause(0.5); 
                        disp('active_obstacle_avoidance: 机械臂已尝试停止。准备重新规划。');
                        break; 
                    else
                        disp('active_obstacle_avoidance: [监测中] 环境稳定，继续执行轨迹。');
                    end
                elseif ~isempty(valResp) && ~valResp.Success % 验证服务调用本身成功，但返回验证操作失败
                    warning('active_obstacle_avoidance: [监测中] 环境验证服务报告操作失败: %s。继续执行当前轨迹。', valResp.Message);
                else % valResp 为空 (超时或严重错误)
                    warning('active_obstacle_avoidance: [监测中] 环境验证服务未返回有效响应。继续执行当前轨迹。');
                end
            else
                disp('active_obstacle_avoidance: [监测中] 未能获取点云进行验证，继续执行。');
            end
        end % end monitoring while loop (toc(trajectoryMonitoringStartTime) < effectiveTrajectoryTimeout_s)

        if toc(trajectoryMonitoringStartTime) >= effectiveTrajectoryTimeout_s && ~pathExecutionInterrupted && ~trajectoryDone
            warning('active_obstacle_avoidance: 轨迹执行监测超时。');
            % 在超时后，也应该尝试停止机械臂，以防失控
            if ~pathExecutionInterrupted % 避免重复发送停止
                disp('active_obstacle_avoidance: 因监测超时，尝试停止机械臂...');
                pathExecutionInterrupted = true; % 标记为中断以触发重规划或结束
                stopTrajMsgOnTimeout = create_stop_trajectory_active(jointStateSub, jointNames, robot, currentConfigStruct);
				send(trajPub, stopTrajMsgOnTimeout);
                pause(1.0); % 等待停止命令生效
            end
        end
        % ... (后续的轨迹执行完毕或被中断后，检查状态逻辑不变) ...

        % 2.4 轨迹执行完毕或被中断后，检查状态
        if pathExecutionInterrupted
            disp('active_obstacle_avoidance: 路径执行被中断，将尝试重新规划。');
            plannerAttempt = plannerAttempt + 1;
            pause(1); % 短暂等待再开始新的规划尝试
            continue; % 返回主循环顶部进行重规划
        end

        disp('active_obstacle_avoidance: 轨迹执行完毕（或未被中断）。检查是否到达目标...');
        pause(1.0); % 确保控制器有时间更新最终状态
        disp('active_obstacle_avoidance: 获取最终手臂状态以检查目标到达情况...');
        [finalJointValues, finalConfigStruct, finalEePoseStruct, finalStateSuccess] = ...
            get_current_arm_state_active(jointStateSub, robot, jointNames, currentConfigStruct); % 使用 currentConfigStruct 作为 prev

        if ~finalStateSuccess
            warning('active_obstacle_avoidance: 未能成功获取最终手臂状态。无法准确判断是否到达目标。');
        else
            currentJointValues = finalJointValues; % 更新 currentJointValues 供下一次迭代起始
            currentConfigStruct = finalConfigStruct; % 更新 currentConfigStruct 供下一次迭代起始

            finalEePos = finalEePoseStruct.position;
            distanceToGoal = norm(finalEePos - goalPosition_target);
            disp(['active_obstacle_avoidance: 最终末端位置: [', num2str(finalEePos), '], 距离目标: ', num2str(distanceToGoal), ' 米']);

            if distanceToGoal < goal_tolerance
                disp(['active_obstacle_avoidance: 成功到达目标位置 (容差: ', num2str(goal_tolerance), 'm)!']);
                reachedGoal = true;
                % break; % 从while循环跳出，如果这是在while循环的末尾，break会生效
            else
                disp('active_obstacle_avoidance: 未到达目标位置。');
            end
        end
        % 如果 reachedGoal 为 true，外部的 while ~reachedGoal 会处理循环退出

        plannerAttempt = plannerAttempt + 1;
        if ~reachedGoal
            disp('active_obstacle_avoidance: 等待1秒后进入下一次规划尝试...');
            pause(1);
        end
    end % end main while loop

    if ~reachedGoal
        disp(['active_obstacle_avoidance: 达到最大规划尝试次数 (', num2str(maxPlannerAttempts), ')，未能到达目标位置。']);
    end

    disp('active_obstacle_avoidance: 主动避障任务结束。');
    % rosshutdown; % 由main.m或用户控制
end

% 辅助函数：创建停止轨迹
% 确保此函数在 active_obstacle_avoidance 内部或MATLAB路径上可以被调用
function stopTrajMsg = create_stop_trajectory_active(jointStateSub_in, jointNamesList_in, robotModel_in, prevConfigStruct_in)
    % jointStateSub_in: ROS订阅器
    % jointNamesList_in: 关节名称
    % robotModel_in: 机器人模型
    % prevConfigStruct_in: 用于获取状态失败时的回退配置

    disp('create_stop_trajectory_active: 获取当前关节状态以生成停止轨迹...');
    [currentStopJointValues, ~, ~, stopStateSuccess] = ...
        get_current_arm_state_active(jointStateSub_in, robotModel_in, jointNamesList_in, prevConfigStruct_in);

    if ~stopStateSuccess
        warning('create_stop_trajectory_active: 获取关节状态失败。停止轨迹可能基于旧值或默认值。');
        % currentStopJointValues 将包含基于 prevConfigStruct_in 的值
    end

    stopTrajMsg = rosmessage('trajectory_msgs/JointTrajectory');
    stopTrajMsg.JointNames = jointNamesList_in;
    point = rosmessage('trajectory_msgs/JointTrajectoryPoint');

    point.Positions = currentStopJointValues; % 使用获取到的或回退的当前位置
    point.Velocities = zeros(1, length(jointNamesList_in)); % 速度和加速度为0
    point.Accelerations = zeros(1, length(jointNamesList_in));
    point.TimeFromStart = rosduration(0.25); % 快速到达当前位置（即停止）,原0.5
    stopTrajMsg.Points = point;
    disp('create_stop_trajectory_active: 停止轨迹已生成。');
end

function [currentJointValues_out, currentConfigStruct_out, currentEePoseStruct_out, success_out] = get_current_arm_state_active(jointStateSub, robotModel, jointNamesList, prevConfigStruct)
    % jointStateSub: ROS订阅器到 /custom_arm/joint_states
    % robotModel: rigidBodyTree模型
    % jointNamesList: 关节名称单元数组
    % prevConfigStruct: 上一个配置结构体，用于在接收失败时提供默认值或部分更新
    
    success_out = false;
    % 使用相对短的超时时间，因为此函数可能在循环中被频繁调用
    jointStateMsg = receive(jointStateSub, 2.0); 
    
    % 初始化输出，基于上一个状态或模型默认
    currentConfigStruct_out = prevConfigStruct; 
    numJoints = length(jointNamesList);
    currentJointValues_out = zeros(1, numJoints);
    for j_idx = 1:numJoints
        currentJointValues_out(j_idx) = prevConfigStruct(j_idx).JointPosition;
    end

    if ~isempty(jointStateMsg)
        if isprop(jointStateMsg, 'Name') && isprop(jointStateMsg, 'Position') && ~isempty(jointStateMsg.Name) && ~isempty(jointStateMsg.Position)
            valid_joints_in_msg = 0;
            for i = 1:numJoints
                jointName = jointNamesList{i};
                [isMember, idx] = ismember(jointName, jointStateMsg.Name);
                if isMember && idx > 0 && idx <= length(jointStateMsg.Position)
                    currentJointValues_out(i) = jointStateMsg.Position(idx);
                    currentConfigStruct_out(i).JointPosition = jointStateMsg.Position(idx);
                    valid_joints_in_msg = valid_joints_in_msg + 1;
                else
                    % 若特定关节未在消息中找到，则保留其在prevConfigStruct中的值
                    currentJointValues_out(i) = prevConfigStruct(i).JointPosition; 
                    currentConfigStruct_out(i).JointPosition = prevConfigStruct(i).JointPosition;
                    warning('get_current_arm_state_active: 关节 %s 在接收到的JointState消息中未找到或索引无效。使用先前值。', jointName);
                end
            end
            
            % 仅当所有预期的关节都在消息中找到并更新时，才认为完全成功
            if valid_joints_in_msg == numJoints
                success_out = true;
            else
                warning('get_current_arm_state_active: 未能在JointState消息中更新所有预期的关节。');
            end
        else
            warning('get_current_arm_state_active: 接收到的JointState消息缺少 Name 或 Position 字段，或它们为空。');
        end
    else
        warning('get_current_arm_state_active: 未能接收到关节状态消息。将使用基于先前配置的值。');
        % currentJointValues_out 和 currentConfigStruct_out 已基于 prevConfigStruct 初始化
    end
    
    % 计算EE位姿
    eeTform_internal = getTransform(robotModel, currentConfigStruct_out, 'tool0');
    currentEePoseStruct_out.position = tform2trvec(eeTform_internal);
    currentEePoseStruct_out.orientation_quat = tform2quat(eeTform_internal); % [w, x, y, z]
end

function poseStampedMsg_out = populate_pose_stamped_msg_active(frameId_in, positionVec_in, orientationQuat_in)
    % frameId_in: 字符串，例如 'base_link'
    % positionVec_in: 1x3 double, [x, y, z]
    % orientationQuat_in: 1x4 double, [w, x, y, z]
    
    poseStampedMsg_out = rosmessage('geometry_msgs/PoseStamped');
    poseStampedMsg_out.Header.FrameId = frameId_in;
    poseStampedMsg_out.Header.Stamp = rostime('now'); % 使用当前ROS时间
    
    poseStampedMsg_out.Pose.Position.X = positionVec_in(1);
    poseStampedMsg_out.Pose.Position.Y = positionVec_in(2);
    poseStampedMsg_out.Pose.Position.Z = positionVec_in(3);
    
    poseStampedMsg_out.Pose.Orientation.W = orientationQuat_in(1);
    poseStampedMsg_out.Pose.Orientation.X = orientationQuat_in(2);
    poseStampedMsg_out.Pose.Orientation.Y = orientationQuat_in(3);
    poseStampedMsg_out.Pose.Orientation.Z = orientationQuat_in(4);
end
```

### 5.9 创建完整的主脚本
最后，我们创建一个主脚本，用于启动整个系统。创建脚本文件main.m：
```matlab
%% 基于主动避障的机械臂点到点运动规划
% 本脚本实现了一个完整的机械臂主动避障系统，包括：
% 1. 连接到ROS/Gazebo
% 2. 创建机械臂模型
% 3. 接收环境感知数据
% 4. 规划避障路径
% 5. 执行轨迹并监测环境变化
% 6. 在检测到新障碍物时重新规划路径

%% 清空工作区并关闭所有窗口
clear;
close all;
clc;

%% 检查ROS连接状态
try
    rosnode list;
    disp('已连接到ROS主节点');
catch
    disp('未连接到ROS主节点，尝试连接...');
    connect_to_ros();
end

%% 显示菜单
disp('=== 机械臂主动避障系统 ===');
disp('1. 执行基本避障任务');
disp('2. 执行主动避障任务');
disp('3. 测试机械臂控制');
disp('4. 测试点云处理');
disp('5. 退出');

choice = input('请选择功能 (1-5): ');

%% 根据用户选择执行相应功能
switch choice
    case 1
        disp('执行基本避障任务...');
        arm_obstacle_avoidance();
    case 2
        disp('执行主动避障任务...');
        active_obstacle_avoidance();
    case 3
        disp('测试机械臂控制...');
        test_arm_control();
    case 4
        disp('测试点云处理...');
        test_point_cloud_processing();
    case 5
        disp('退出程序');
        if ~isempty(rosdevice.MasterURI)
            rosshutdown;
        end
        return;
    otherwise
        disp('无效选择，请重新运行程序');
end

%% 辅助函数：测试机械臂控制
function test_arm_control()
    % 连接到ROS
    if isempty(rosdevice.MasterURI)
        connect_to_ros();
    end
    
    % 创建轨迹发布者
    trajPub = rospublisher('/custom_arm/arm_controller/command', 'trajectory_msgs/JointTrajectory');
    
    % 关节名称
    jointNames = {
        'shoulder_pan_joint',
        'shoulder_lift_joint',
        'elbow_joint',
        'wrist_1_joint',
        'wrist_2_joint',
        'wrist_3_joint'
    };
    
    % 创建轨迹消息
    trajMsg = rosmessage(trajPub);
    trajMsg.JointNames = jointNames;
    
    % 创建一系列测试姿态
    poses = [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0;  % 初始位置
        0.5, 0.0, 0.0, 0.0, 0.0, 0.0;  % 旋转肩部
        0.5, 0.5, 0.0, 0.0, 0.0, 0.0;  % 抬起上臂
        0.5, 0.5, 0.5, 0.0, 0.0, 0.0;  % 弯曲肘部
        0.5, 0.5, 0.5, 0.5, 0.0, 0.0;  % 旋转腕部1
        0.5, 0.5, 0.5, 0.5, 0.5, 0.0;  % 旋转腕部2
        0.5, 0.5, 0.5, 0.5, 0.5, 0.5;  % 旋转腕部3
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0   % 返回初始位置
    ];
    
    % 执行每个姿态
    for i = 1:size(poses, 1)
        % 清空轨迹点
        trajMsg.Points = [];
        
        % 创建轨迹点
        point = rosmessage('trajectory_msgs/JointTrajectoryPoint');
        point.Positions = poses(i, :);
        point.Velocities = zeros(1, 6);
        point.Accelerations = zeros(1, 6);
        point.TimeFromStart = rosduration(2.0);
        
        % 添加轨迹点
        trajMsg.Points = point;
        
        % 发送轨迹命令
        disp(['发送姿态 ', num2str(i), '/', num2str(size(poses, 1))]);
        send(trajPub, trajMsg);
        
        % 等待执行完成
        pause(3);
    end
    
    disp('机械臂控制测试完成');
end

%% 辅助函数：测试点云处理
function test_point_cloud_processing()
    % 连接到ROS
    if isempty(rosdevice.MasterURI)
        connect_to_ros();
    end
    
    % 创建机械臂模型
    robot = create_robot_model();
    
    % 创建点云订阅者
    pointCloudSub = rossubscriber('/camera/depth/points', 'sensor_msgs/PointCloud2');
    
    % 等待接收点云数据
    disp('等待接收点云数据...');
    pointCloudMsg = receive(pointCloudSub, 10);
    
    % 处理点云数据
    [obstacleObjects, processedPointCloud] = process_point_cloud(pointCloudMsg, robot);
    
    % 显示结果
    disp(['识别到 ', num2str(length(obstacleObjects)), ' 个障碍物']);
    
    % 可视化障碍物和处理后的点云
    figure;
    pcshow(processedPointCloud); % 显示处理后的点云
    title('处理后的点云数据和识别的障碍物'); % 更新标题以反映内容
    hold on;
    axis equal; % 保持坐标轴比例一致，使物体形状正确
    grid on;    % 显示网格
    xlabel('X (m)'); % 添加坐标轴标签
    ylabel('Y (m)');
    zlabel('Z (m)');
    view(3); % 设置为三维视角

    % 显示识别出的障碍物边界框
    if ~isempty(obstacleObjects)
        disp(['正在可视化 ', num2str(length(obstacleObjects)), ' 个识别的障碍物...']);
        for i = 1:length(obstacleObjects)
            obs = obstacleObjects{i};
            if isa(obs, 'collisionBox')
                % 使用 show 函数显示 collisionBox 对象
                % show 函数会自动使用 obs.Pose 来确定其位置和方向
                show(obs); 
                % 您也可以使用 plot 函数并指定颜色和透明度，例如:
                % plot(obs, 'FaceColor', 'r', 'FaceAlpha', 0.3, 'EdgeColor', 'k');
            elseif isa(obs, 'collisionCylinder') || isa(obs, 'collisionSphere')
                % 如果 process_point_cloud 也输出这些类型，同样处理
                show(obs);
            else
                warning('test_point_cloud_processing: 未知障碍物类型，无法可视化。');
            end
        end
    else
        disp('没有识别到障碍物进行可视化。');
    end
    
    hold off;
    disp('点云处理测试完成。');
end
```
### 5.10 运行系统
**启动ROS环境、Gazebo仿真及核心服务：** 在Ubuntu终端中执行以下命令。这将启动Gazebo仿真、加载机器人模型、启动控制器，并非常关键地，**启动 `planning_service.py` ROS节点**（通过 `planning_service.launch` 被包含在 `arm_obstacle_avoidance.launch` 中）。

```bash
# 在Ubuntu终端中
cd ~/catkin_ws
source devel/setup.bash
roslaunch arm_obstacle_avoidance arm_obstacle_avoidance.launch
```

**启动MATLAB规划器节点：** 在MATLAB命令窗口中，**首先导航到包含 `matlab_ros_planner.m` 脚本的目录**，然后运行它。此脚本将作为一个后台ROS节点运行，等待来自 `planning_service.py` 的规划请求。

```matlab
% 确保已执行 connect_to_ros() 或已通过 rosinit 连接到ROS主控
rosinit('http://192.168.110.23:11311', 'NodeHost', '192.168.110.151');
rosgenmsg('C:\Users\SNight\Documents\vm disk\copy');   #第一次运行
matlab_ros_planner
% 此脚本启动后会持续运行，监听ROS话题。
```

**在MATLAB中运行主控制脚本：** 在 `matlab_ros_planner.m` 正在运行的**同一个MATLAB实例中（或确保新的MATLAB实例也正确连接到ROS并配置了NodeHost）**，运行主脚本 `main.m`，然后根据菜单选择功能。

```matlab
% 在MATLAB命令窗口中 (确保已连接ROS)
main
```



### 5.11 系统工作流程

**系统工作流程（基于ROS服务架构）：**

整个系统通过MATLAB与ROS之间的紧密协作，实现了主动避障功能。核心流程围绕着ROS服务 `/request_robot_plan` 进行。

**初始化阶段：**

1. ROS端：

   - 启动 Gazebo 仿真环境，加载机械臂模型和世界（包含障碍物和传感器）。
   - 启动 `planning_service.py` ROS节点，该节点提供 `/request_robot_plan` 服务，并准备好通过ROS主题与MATLAB规划器节点通信。

2. MATLAB端：

   - 用户通过 `connect_to_ros()` (或 `rosinit`) 连接到ROS主控。

   - 启动 `matlab_ros_planner.m`脚本。此脚本作为一个MATLAB ROS节点运行，它会：

     - 加载机械臂模型 (`create_robot_model`)。
     - 订阅 `/matlab_planning/request_data` 主题以接收规划请求。
     - 创建到 `/matlab_planning/planning_status` 主题的发布器以发送规划结果。

   - 主控制脚本（如 `arm_obstacle_avoidance.m`或`active_obstacle_avoidance.m`）被调用：

     - 创建到 `/request_robot_plan` 服务的客户端。
     - 获取机械臂初始状态（关节角度）。
     - 定义最终的目标位姿。

**主循环（以 `active_obstacle_avoidance.m` 为例）：**

1. **感知与服务请求准备（MATLAB主脚本）：**
   - 从 `/camera/depth/points` 订阅最新的点云数据。
   - 获取当前的关节状态。
   - 构建 `/request_robot_plan` 服务的请求消息，填充当前点云、当前关节值、当前末端执行器估计位姿以及目标末端执行器位姿。
2. **调用规划服务（MATLAB主脚本 -> ROS服务 -> MATLAB规划器）：**
   - MATLAB主脚本通过服务客户端向 `/request_robot_plan` 服务发送请求。
   - `planning_service.py` (ROS Python节点) 接收到服务请求。
   - `planning_service.py` 将请求数据发布到 `/matlab_planning/request_data` ROS主题。
3. **实际路径规划（MATLAB规划器节点 `matlab_ros_planner.m`）：**
   - `matlab_ros_planner.m` 接收到来自 `/matlab_planning/request_data` 的消息。
   - 调用 `process_point_cloud` 处理点云数据，识别障碍物。
   - 调用 `inverseKinematics` (如果需要，通常目标是位姿) 计算目标关节配置。
   - 调用 `plan_path` (RRT算法) 规划从当前配置到目标配置的无碰撞路径。
   - 调用 `generate_trajectory` 生成平滑的关节轨迹消息 (`trajectory_msgs/JointTrajectory`)。
   - 将规划结果（是否成功、消息、轨迹）通过 `/matlab_planning/planning_status` ROS主题发布出去。
4. **服务响应与轨迹获取（ROS服务 -> MATLAB主脚本）：**
   - `planning_service.py` 订阅 `/matlab_planning/planning_status` 主题，接收到MATLAB规划器节点的规划结果。
   - `planning_service.py` 将此结果作为对 `/request_robot_plan` 服务的响应返回给MATLAB主脚本。
   - MATLAB主脚本接收到服务响应，如果成功，则提取出规划好的轨迹。
5. **执行与监测（MATLAB主脚本）：**
   - 调用 `control_arm` 函数，将接收到的轨迹发送给 `/custom_arm/arm_controller/command` ROS话题，由Gazebo中的控制器执行。
   - 在轨迹执行期间，`active_obstacle_avoidance.m` 会持续从 `/camera/depth/points` 接收点云数据。
   - 调用 `process_point_cloud` 处理新的点云，并与之前的障碍物状态比较 (`detect_obstacle_changes`)。
6. **重规划决策（MATLAB主脚本）：**
   - 如果监测到显著的障碍物变化导致当前路径可能被阻塞：
     - 立即发送停止命令给机械臂控制器。
     - 更新当前状态（关节角度、点云）。
     - **返回到步骤1**，以新的环境信息重新请求路径规划。
   - 如果轨迹执行完毕但未检测到阻碍，检查是否到达目标位置。

**完成阶段：**

- 如果机械臂末端到达目标位置（在一定容差内），则任务成功。
- 如果多次尝试（包括重规划）后仍未到达目标，或规划持续失败，则任务结束（可能失败）。
- 最终，可以断开与ROS的连接 (`rosshutdown`)。

## 6. 可视化

在机器人开发和调试过程中，可视化扮演着至关重要的角色。它不仅能帮助理解机器人的行为，还能有效地定位问题。本项目将主要利用Gazebo和RViz进行可视化。

### 6.1. 可视化工具的协同使用

在第4节中，我们已经搭建了基于Gazebo的仿真环境和RViz的可视化配置。这两种工具各有优势，协同使用可以提供全面的系统视图：
| 工具 | 主要功能 | 已实现功能(前面章节) | 高级应用(本节) |
|------|---------|-------------------|--------------|
| Gazebo | 物理仿真与场景渲染 | 基本环境搭建(4.5节)<br>机械臂加载(4.6节) | 动态视角切换<br>录制高质量视频 |
| RViz | ROS数据可视化 | 基本配置(4.7节) | 自定义显示插件<br>多视图布局<br>交互式标记 |

#### 6.1.1 Gazebo与RViz的视角同步
为了同时观察物理仿真和数据可视化，可以实现Gazebo与RViz视角的同步：
```python
#!/usr/bin/env python
# 创建文件: ~/catkin_ws/src/arm_obstacle_avoidance/scripts/view_sync.py

import rospy
from gazebo_msgs.msg import ModelStates
from std_msgs.msg import Float64MultiArray
from geometry_msgs.msg import PoseStamped
import tf2_ros
import tf.transformations

class ViewSynchronizer:
    def __init__(self):
        rospy.init_node('view_synchronizer')
        
        # 创建TF广播器
        self.tf_broadcaster = tf2_ros.TransformBroadcaster()
        
        # 订阅Gazebo相机位置
        self.gazebo_sub = rospy.Subscriber('/gazebo/model_states', 
                                          ModelStates, 
                                          self.gazebo_callback)
        
        # 发布RViz相机视角
        self.rviz_pub = rospy.Publisher('/rviz_camera_pose', 
                                        PoseStamped, 
                                        queue_size=1)
        
        rospy.loginfo("视角同步节点已启动")
        
    def gazebo_callback(self, data):
        try:
            # 查找用户相机模型索引
            if 'user_camera' in data.name:
                idx = data.name.index('user_camera')
                camera_pose = data.pose[idx]
                
                # 创建并发布RViz相机位姿
                pose_msg = PoseStamped()
                pose_msg.header.stamp = rospy.Time.now()
                pose_msg.header.frame_id = "world"
                pose_msg.pose = camera_pose
                self.rviz_pub.publish(pose_msg)
        except Exception as e:
            rospy.logwarn(f"处理相机位置时出错: {e}")

if __name__ == '__main__':
    try:
        synchronizer = ViewSynchronizer()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
```

**覆盖 `~/catkin_ws/src/arm_obstacle_avoidance/launch/arm_obstacle_avoidance.launch` 的内容：**

```xml
<?xml version="1.0"?>
<launch>
  <include file="$(find arm_obstacle_avoidance)/launch/arm_gazebo.launch" />

  <include file="$(find arm_obstacle_avoidance)/launch/planning_service.launch" />

  <node name="move_obstacle" pkg="arm_obstacle_avoidance" type="move_obstacle.py" output="screen" />

  <node name="view_synchronizer" pkg="arm_obstacle_avoidance" type="view_sync.py" output="screen" />

  <node name="interactive_target" pkg="arm_obstacle_avoidance" type="interactive_target.py" output="screen" />
</launch>
```

添加可执行权限：

```bash
chmod +x ~/catkin_ws/src/arm_obstacle_avoidance/scripts/view_sync.py
```



### 6.2 高级RViz配置与技巧

RViz是一个强大的可视化工具，在4.7节我们已经创建了基本配置。以下是一些高级技巧：
#### 6.2.1 创建多面板布局
通过修改RViz配置文件，可以创建多面板布局，同时显示不同类型的数据：
```bash
# 打开RViz并保存当前配置
rosrun rviz rviz -d ~/catkin_ws/src/arm_obstacle_avoidance/config/arm_config.rviz
```
在RViz界面:
点击"Panels" → "Add New Panel"
添加"Image"面板用于显示相机图像
添加"Plot"面板用于显示关节轨迹
使用"Views"面板创建多个视角
保存配置到同一文件

#### 6.2.2 添加交互式标记
交互式标记(Interactive Markers)允许用户在RViz中直接与机械臂交互。创建以下脚本:
```python
#!/usr/bin/env python
# 创建文件: ~/catkin_ws/src/arm_obstacle_avoidance/scripts/interactive_target.py

import rospy
import copy
from interactive_markers.interactive_marker_server import *
from interactive_markers.menu_handler import *
from visualization_msgs.msg import *
from geometry_msgs.msg import PoseStamped

class InteractiveTargetNode:
    def __init__(self):
        rospy.init_node("interactive_target_node")
        
        # 创建交互式标记服务器
        self.server = InteractiveMarkerServer("target_marker")
        
        # 创建菜单处理器
        self.menu_handler = MenuHandler()
        self.menu_handler.insert("设为目标点", callback=self.process_feedback)
        
        # 创建目标发布器
        self.target_pub = rospy.Publisher('/target_pose', 
                                         PoseStamped, 
                                         queue_size=1)
        
        # 创建交互式标记
        self.make_6dof_marker()
        self.server.applyChanges()
        
        rospy.loginfo("交互式目标点节点已启动")
    
    def process_feedback(self, feedback):
        if feedback.event_type == InteractiveMarkerFeedback.MENU_SELECT:
            # 发布目标位姿
            pose_msg = PoseStamped()
            pose_msg.header = feedback.header
            pose_msg.pose = feedback.pose
            self.target_pub.publish(pose_msg)
            rospy.loginfo(f"已设置新目标点: [{pose_msg.pose.position.x:.2f}, {pose_msg.pose.position.y:.2f}, {pose_msg.pose.position.z:.2f}]")
    
    def make_6dof_marker(self):
        int_marker = InteractiveMarker()
        int_marker.header.frame_id = "base_link"
        int_marker.pose.position.z = 0.4
        int_marker.scale = 0.3
        int_marker.name = "target_6dof"
        int_marker.description = "目标点 (6-DOF)"
        
        # 创建箭头标记
        control = InteractiveMarkerControl()
        control.orientation.w = 1
        control.orientation.x = 1
        control.orientation.y = 0
        control.orientation.z = 0
        control.name = "rotate_x"
        control.interaction_mode = InteractiveMarkerControl.ROTATE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        control.name = "move_x"
        control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        
        control.orientation.x = 0
        control.orientation.y = 1
        control.name = "rotate_y"
        control.interaction_mode = InteractiveMarkerControl.ROTATE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        control.name = "move_y"
        control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        
        control.orientation.y = 0
        control.orientation.z = 1
        control.name = "rotate_z"
        control.interaction_mode = InteractiveMarkerControl.ROTATE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        control.name = "move_z"
        control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
        int_marker.controls.append(copy.deepcopy(control))
        
        # 添加视觉标记
        marker = Marker()
        marker.type = Marker.SPHERE
        marker.scale.x = 0.06
        marker.scale.y = 0.06
        marker.scale.z = 0.06
        marker.color.r = 1.0
        marker.color.g = 1.0
        marker.color.b = 0.0
        marker.color.a = 1.0
        
        control = InteractiveMarkerControl()
        control.always_visible = True
        control.markers.append(marker)
        int_marker.controls.append(control)
        
        # 添加到服务器
        self.server.insert(int_marker, self.process_feedback)
        self.menu_handler.apply(self.server, int_marker.name)

if __name__ == "__main__":
    try:
        InteractiveTargetNode()
        rospy.spin()
    except rospy.ROSInterruptException:
        pass
```

将此节点添加到启动文件:
```xml
<node name="interactive_target" pkg="arm_obstacle_avoidance" type="interactive_target.py" output="screen" />
```
添加可执行权限：

```bash
chmod +x ~/catkin_ws/src/arm_obstacle_avoidance/scripts/interactive_target.py
```



在MATLAB中接收交互式设置的目标点:

```matlab
% 创建目标点订阅者
targetSub = rossubscriber('/target_pose', 'geometry_msgs/PoseStamped');

% 在主循环中接收目标点
targetMsg = receive(targetSub, 0.1);  % 非阻塞接收
if ~isempty(targetMsg)
    % 更新目标位置
    goalPosition = [targetMsg.Pose.Position.X, ...
                   targetMsg.Pose.Position.Y, ...
                   targetMsg.Pose.Position.Z];
    
    % 更新目标四元数
    goalOrientation = [targetMsg.Pose.Orientation.W, ...
                      targetMsg.Pose.Orientation.X, ...
                      targetMsg.Pose.Orientation.Y, ...
                      targetMsg.Pose.Orientation.Z];
    
    disp(['收到新目标点: [', num2str(goalPosition), ']']);
    
    % 更新目标配置...
end
```

### 6.3 从MATLAB发布高级可视化数据
在第5节中，我们已经实现了基本的机械臂控制和路径规划。现在，我们将添加更高级的可视化功能。

#### 6.3.1 可视化规划树和探索空间
在RRT规划过程中，可视化规划树和探索空间有助于理解算法的工作过程。修改plan_path.m函数:
```matlab
function [path, success] = plan_path(robot, startConfig, goalConfig, obstacleObjects)
    % 创建RRT路径规划器
    planner = manipulatorRRT(robot, obstacleObjects);
    
    % 设置规划器参数
    planner.MaxConnectionDistance = 0.5;  % 连接距离
    planner.MaxIterations = 5000;         % 最大迭代次数
    planner.ValidationDistance = 0.1;     % 碰撞检测步长
    
    % 创建RRT树可视化发布者
    treePub = rospublisher('/planning_tree', 'visualization_msgs/MarkerArray');
    treeMsg = rosmessage(treePub);
    
    % 规划路径
    disp('开始路径规划...');
    tic;  % 开始计时
    
    % 创建回调函数以可视化规划过程
    function visualizeTree(planner, problem)
        % 获取树节点和边
        [v, e] = extractStateTree(planner, problem);
        
        % 清空之前的标记
        treeMsg.Markers = [];
        
        % 创建节点标记
        for i = 1:size(v, 1)
            config = v(i, :);
            marker = rosmessage('visualization_msgs/Marker');
            marker.Header.FrameId = 'base_link';
            marker.Header.Stamp = rostime('now');
            marker.Id = i;
            marker.Type = marker.SPHERE;
            marker.Action = marker.ADD;
            marker.Scale.X = 0.03;
            marker.Scale.Y = 0.03;
            marker.Scale.Z = 0.03;
            marker.Color.R = 0.0;
            marker.Color.G = 0.7;
            marker.Color.B = 0.2;
            marker.Color.A = 0.5;
            
            % 计算节点在笛卡尔空间中的位置
            eeTform = getTransform(robot, config, 'tool0');
            marker.Pose.Position.X = eeTform(1, 4);
            marker.Pose.Position.Y = eeTform(2, 4);
            marker.Pose.Position.Z = eeTform(3, 4);
            marker.Pose.Orientation.W = 1.0;
            
            treeMsg.Markers = [treeMsg.Markers; marker];
        end
        
        % 创建边标记
        for i = 1:size(e, 1)
            startIdx = e(i, 1);
            endIdx = e(i, 2);
            
            marker = rosmessage('visualization_msgs/Marker');
            marker.Header.FrameId = 'base_link';
            marker.Header.Stamp = rostime('now');
            marker.Id = size(v, 1) + i;
            marker.Type = marker.LINE_STRIP;
            marker.Action = marker.ADD;
            marker.Scale.X = 0.015;
            marker.Color.R = 0.0;
            marker.Color.G = 0.5;
            marker.Color.B = 0.9;
            marker.Color.A = 0.5;
            
            % 添加起点和终点
            p1 = rosmessage('geometry_msgs/Point');
            eeTform = getTransform(robot, v(startIdx, :), 'tool0');
            p1.X = eeTform(1, 4);
            p1.Y = eeTform(2, 4);
            p1.Z = eeTform(3, 4);
            
            p2 = rosmessage('geometry_msgs/Point');
            eeTform = getTransform(robot, v(endIdx, :), 'tool0');
            p2.X = eeTform(1, 4);
            p2.Y = eeTform(2, 4);
            p2.Z = eeTform(3, 4);
            
            marker.Points = [p1; p2];
            
            treeMsg.Markers = [treeMsg.Markers; marker];
        end
        
        % 发布标记数组
        send(treePub, treeMsg);
    end
    
    % 设置规划回调
    planner.VisualizationCallback = @visualizeTree;
    
    % 执行规划
    [path, solnInfo] = plan(planner, startConfig, goalConfig);
    planningTime = toc;  % 结束计时
    
    % 检查规划结果
    if solnInfo.IsPathFound
        disp(['路径规划成功，用时 ', num2str(planningTime), ' 秒']);
        
        % 尝试缩短路径
        path = shorten(path);
        
        % 插值以获得更平滑的路径
        path = interpolate(path, 100);
        
        % 可视化最终路径
        visualizeFinalPath(robot, path, obstacleObjects);
        
        success = true;
    else
        disp('路径规划失败');
        path = [];
        success = false;
    end
end

% 可视化最终路径
function visualizeFinalPath(robot, path, obstacleObjects)
    % 创建路径发布者
    pathPub = rospublisher('/planned_path', 'nav_msgs/Path');
    pathMsg = rosmessage(pathPub);
    pathMsg.Header.FrameId = 'base_link';
    pathMsg.Header.Stamp = rostime('now');
    
    % 添加路径点
    for i = 1:size(path.States, 1)
        config = path.States(i, :);
        
        % 计算末端执行器位置
        eeTform = getTransform(robot, config, 'tool0');
        
        % 创建位姿
        poseSt = rosmessage('geometry_msgs/PoseStamped');
        poseSt.Header = pathMsg.Header;
        poseSt.Pose.Position.X = eeTform(1, 4);
        poseSt.Pose.Position.Y = eeTform(2, 4);
        poseSt.Pose.Position.Z = eeTform(3, 4);
        
        % 从变换矩阵提取四元数
        quat = rotm2quat(eeTform(1:3, 1:3));
        poseSt.Pose.Orientation.W = quat(1);
        poseSt.Pose.Orientation.X = quat(2);
        poseSt.Pose.Orientation.Y = quat(3);
        poseSt.Pose.Orientation.Z = quat(4);
        
        % 添加到路径消息
        pathMsg.Poses = [pathMsg.Poses; poseSt];
    end
    
    % 发布路径
    send(pathPub, pathMsg);
end
```

#### 6.3.2 可视化碰撞检测和避障过程
为了更好地理解避障过程，可以可视化碰撞检测和避障决策:
```matlab
% 添加到active_obstacle_avoidance.m文件中

% 创建碰撞可视化发布者
collisionPub = rospublisher('/collision_visualization', 'visualization_msgs/MarkerArray');
collisionMsg = rosmessage(collisionPub);

% 可视化碰撞检测
function visualizeCollisionCheck(config, isColliding)
    % 清空之前的标记
    collisionMsg.Markers = [];
    
    % 计算末端执行器位置
    eeTform = getTransform(robot, config, 'tool0');
    
    % 创建碰撞检测可视化标记
    marker = rosmessage('visualization_msgs/Marker');
    marker.Header.FrameId = 'base_link';
    marker.Header.Stamp = rostime('now');
    marker.Id = 1;
    marker.Type = marker.SPHERE;
    marker.Action = marker.ADD;
    marker.Scale.X = 0.06;
    marker.Scale.Y = 0.06;
    marker.Scale.Z = 0.06;
    
    if isColliding
        % 红色表示碰撞
        marker.Color.R = 1.0;
        marker.Color.G = 0.0;
        marker.Color.B = 0.0;
    else
        % 绿色表示无碰撞
        marker.Color.R = 0.0;
        marker.Color.G = 1.0;
        marker.Color.B = 0.0;
    end
    marker.Color.A = 0.8;
    
    marker.Pose.Position.X = eeTform(1, 4);
    marker.Pose.Position.Y = eeTform(2, 4);
    marker.Pose.Position.Z = eeTform(3, 4);
    marker.Pose.Orientation.W = 1.0;
    
    collisionMsg.Markers = [collisionMsg.Markers; marker];
    
    % 发布标记数组
    send(collisionPub, collisionMsg);
end
```

### 6.4 录制和回放可视化数据

#### 6.4.1 录制机器人运行数据
创建一个脚本用于录制所有相关话题:
```bash
#!/bin/bash
# 创建文件: ~/catkin_ws/src/arm_obstacle_avoidance/scripts/record_experiment.sh

# 获取当前日期和时间作为文件名
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
BAGFILE="$HOME/catkin_ws/bags/experiment_$TIMESTAMP.bag"

# 确保存储目录存在
mkdir -p $HOME/catkin_ws/bags

# 录制相关话题
rosbag record -O $BAGFILE \
  /custom_arm/joint_states \
  /camera/depth/points \
  /planned_path \
  /planning_tree \
  /collision_visualization \
  /target_pose \
  /tf \
  /tf_static \
  __name:=experiment_recorder
```

使脚本可执行:

```bash
chmod +x ~/catkin_ws/src/arm_obstacle_avoidance/scripts/record_experiment.sh
```

创建文件: ~/catkin_ws/src/arm_obstacle_avoidance/launch/visualize_experiment.launch

```xml
<launch>
  <!-- 参数: 要回放的bag文件路径 -->
  <arg name="bagfile" default=""/>
  
  <!-- 加载机械臂描述 -->
  <include file="$(find arm_obstacle_avoidance)/launch/load_arm.launch" />
  
  <!-- 启动RViz -->
  <node name="rviz" pkg="rviz" type="rviz" 
        args="-d $(find arm_obstacle_avoidance)/config/visualization_config.rviz" />
  
  <!-- 启动bag回放 -->
  <node pkg="rosbag" type="play" name="rosbag_play" 
        args="--clock $(arg bagfile)" if="$(eval bagfile != '')"/>
  
  <!-- 使用模拟时间 -->
  <param name="/use_sim_time" value="true" if="$(eval bagfile != '')"/>
</launch>
```

在ROS工作空间中，创建或打开以下路径的文件： `~/catkin_ws/src/arm_obstacle_avoidance/config/visualization_config.rviz`
```rviz
Panels:
  - Class: rviz/Displays
    Help Height: 78
    Name: Displays
    Property Tree Widget:
      Expanded:
        - /Global Options1
        - /Grid1
        - /TF1
        - /RobotModel1
        - /PointCloud2_Camera1
        - /Path_PlannedPath1
        - /MarkerArray_PlanningTree1
        - /MarkerArray_CollisionViz1
        - /InteractiveMarkers_TargetMarker1
      Splitter Ratio: 0.55
    Tree Height: 530
  - Class: rviz/Views
    Expanded:
      - /Current View1
    Name: Views
    Splitter Ratio: 0.5
  - Class: rviz/Time
    Name: Time
    SyncMode: 0
    SyncSource: PointCloud2_Camera
Visualization Manager:
  Class: ""
  Displays:
    - Alpha: 0.5
      Cell Size: 1
      Class: rviz/Grid
      Color: 160; 160; 164
      Enabled: true
      Line Style:
        Line Width: 0.03
        Value: Lines
      Name: Grid
      Normal Cell Count: 0
      Offset:
        X: 0
        Y: 0
        Z: 0
      Plane: XY
      Plane Cell Count: 10
      Reference Frame: <Fixed Frame>
      Value: true
    - Class: rviz/TF
      Enabled: true
      Frame Timeout: 15
      Frames:
        All Enabled: true
      Marker Scale: 0.25
      Name: TF
      Show Arrows: true
      Show Axes: true
      Show Names: true
      Tree:
        {}
      Update Interval: 0
      Value: true
    - Alpha: 1
      Class: rviz/RobotModel
      Collision Enabled: false
      Enabled: true
      Links:
        All Links Enabled: true
        Expand Joint Details: false
        Expand Link Details: false
        Expand Tree: false
        Link Tree Style: Links in Alphabetic Order
      Name: RobotModel
      Robot Description: robot_description
      TF Prefix: ""
      Update Interval: 0
      Value: true
      Visual Enabled: true
    - Alpha: 1
      Autocompute Intensity Bounds: true
      Autocompute Value Bounds:
        Max Value: 10
        Min Value: -10
        Value: true
      Axis: Z
      Channel Name: intensity
      Class: rviz/PointCloud2
      Color: 255; 255; 255
      Color Transformer: Intensity
      Decay Time: 0
      Enabled: true
      Max Color: 255; 255; 255
      Max Intensity: 4096
      Min Color: 0; 0; 0
      Min Intensity: 0
      Name: PointCloud2_Camera
      Position Transformer: XYZ
      Queue Size: 10
      Selectable: true
      Size (Pixels): 2
      Size (m): 0.01
      Style: Points
      Topic: /camera/depth/points
      Use Fixed Frame: true
      Use LidarTimestamp: false
      Value: true
    - Alpha: 1
      Buffer Length: 1
      Class: rviz/Path
      Color: 25; 255; 0
      Enabled: true
      Head Diameter: 0.2
      Head Length: 0.15
      Length: 0.2
      Line Style: Lines
      Line Width: 0.04
      Name: Path_PlannedPath
      Offset:
        X: 0
        Y: 0
        Z: 0
      Pose Color: 255; 85; 255
      Pose Style: None
      Radius: 0.03
      Shaft Diameter: 0.08
      Shaft Length: 0.08
      Topic: /planned_path
      Unreliable: false
      Value: true
    - Class: rviz/MarkerArray
      Enabled: true
      Marker Topic: /planning_tree
      Name: MarkerArray_PlanningTree
      Namespaces:
        {}
      Queue Size: 100
      Value: true
    - Class: rviz/MarkerArray
      Enabled: true
      Marker Topic: /collision_visualization
      Name: MarkerArray_CollisionViz
      Namespaces:
        {}
      Queue Size: 100
      Value: true
    - Class: rviz/InteractiveMarkers
      Enabled: true
      Hide Inactive Objects: true
      Name: InteractiveMarkers_TargetMarker
      Show Axes: false
      Show Descriptions: true
      Show Visual Aids: false
      Update Topic: /target_marker/update
      Value: true
  Enabled: true
  Global Options:
    Background Color: 48; 48; 48
    Fixed Frame: base_link
    Frame Rate: 30
  Name: root
  Tools:
    - Class: rviz/Interact
      Hide Inactive Objects: true
    - Class: rviz/MoveCamera
    - Class: rviz/Select
    - Class: rviz/FocusCamera
    - Class: rviz/Measure
      Line color: 128; 128; 0
    - Class: rviz/SetInitialPose
      Topic: /initialpose
    - Class: rviz/SetGoal
      Topic: /move_base_simple/goal
    - Class: rviz/PublishPoint
      Single click: true
      Topic: /clicked_point
  Value: true
  Views:
    Current:
      Class: rviz/Orbit
      Distance: 5.5
      Enable Stereo Rendering:
        Stereo Eye Separation: 0.06
        Stereo Focal Distance: 1
        Swap Stereo Eyes: false
        Value: false
      Focal Point:
        X: 0.6
        Y: 0.1
        Z: 0.4
      Focal Shape Fixed Size: true
      Focal Shape Size: 0.05
      Invert Z Axis: false
      Name: Current View
      Near Clip Distance: 0.01
      Pitch: 0.55
      Target Frame: <Fixed Frame>
      Value: Orbit (rviz)
      Yaw: 0.7853981852531433
Window Geometry:
  Displays:
    collapsed: false
  Height: 864
  Hide Left Dock: false
  Hide Right Dock: false
  InteractiveMarkers_TargetMarker:
    collapsed: false
  Main Window Size: 1440; 864
  MarkerArray_CollisionViz:
    collapsed: false
  MarkerArray_PlanningTree:
    collapsed: false
  Path_PlannedPath:
    collapsed: false
  PointCloud2_Camera:
    collapsed: false
  RobotModel:
    collapsed: false
  TF:
    collapsed: false
  Time:
    collapsed: false
  Views:
    collapsed: false
  X: 60
  Y: 60
```

使用方法：
```bash
# 录制实验数据
~/catkin_ws/src/arm_obstacle_avoidance/scripts/record_experiment.sh

# 回放并可视化
roslaunch arm_obstacle_avoidance visualize_experiment.launch bagfile:=~/catkin_ws/bags/experiment_YYYYMMDD_HHMMSS.bag
```

### 6.5 可视化最佳实践
#### 6.5.1 可视化分层策略
为了提高可视化的清晰度和效率，采用分层可视化策略:
1.**基础层**: 机器人模型、环境、坐标系
在第4节中已经实现，通过RobotModel和TF显示
保持简洁，使用适当的透明度
2.**感知层**: 传感器数据、障碍物识别
在第5.3节中实现的点云处理可视化
使用不同颜色区分原始点云和处理后的障碍物
3.**规划层**: 路径、轨迹、规划树
本节6.3.1中实现的规划树和路径可视化
使用线条粗细、颜色和透明度区分不同元素
4.**交互层**: 用户界面、交互式标记
本节6.2.2中实现的交互式目标点
保持直观、响应迅速

#### 6.5.2 性能优化技巧
在复杂场景中保持可视化性能:
1.**限制可视化数据量:**
```matlab
   % 限制规划树节点数量
   if size(treeMsg.Markers, 1) > 1000
       % 只保留最新的1000个标记
       treeMsg.Markers = treeMsg.Markers(end-999:end);
   end
```

2.**使用适当的更新频率:**
```matlab
   % 降低高计算量可视化的更新频率
   persistent lastUpdateTime
   if isempty(lastUpdateTime) || toc(lastUpdateTime) > 0.2  % 5Hz
       % 更新可视化
       visualizeTree(planner, problem);
       lastUpdateTime = tic;
   end
```

3.**使用Level-of-Detail技术:**
```matlab
   % 根据相机距离调整细节级别
   function adjustDetailLevel(distance)
       if distance > 3.0
           % 远距离: 低细节
           marker.Scale.X = 0.06;
           % 跳过部分节点
           skipFactor = 5;
       elseif distance > 1.5
           % 中距离: 中等细节
           marker.Scale.X = 0.04;
           skipFactor = 2;
       else
           % 近距离: 高细节
           marker.Scale.X = 0.02;
           skipFactor = 1;
       end
       
       % 应用跳过因子
       for i = 1:skipFactor:size(points, 1)
           % 添加点...
       end
   end
```

#### 6.6.3 可视化调试技巧
使用可视化加速调试过程:
1.**状态指示器:**

```matlab
   % 创建状态指示器发布者
   statusPub = rospublisher('/robot_status', 'visualization_msgs/Marker');
   
   % 显示机器人状态
   function showStatus(statusText, statusColor)
       marker = rosmessage('visualization_msgs/Marker');
       marker.Header.FrameId = 'base_link';
       marker.Header.Stamp = rostime('now');
       marker.Id = 999;
       marker.Type = marker.TEXT_VIEW_FACING;
       marker.Action = marker.ADD;
       marker.Scale.Z = 0.15;  % 文本高度
       marker.Color.R = statusColor(1);
       marker.Color.G = statusColor(2);
       marker.Color.B = statusColor(3);
       marker.Color.A = 1.0;
       estimated_robot_height = 0.7; % 对于1米臂展，肩部可能在此高度附近
       marker.Pose.Position.Z = estimated_robot_height + 0.3;  % 显示在机器人上方
       marker.Text = statusText;
       
       send(statusPub, marker);
   end
   
   % 使用示例
   showStatus('规划中...', [1.0, 1.0, 0.0]);  % 黄色
   showStatus('执行轨迹', [0.0, 1.0, 0.0]);   % 绿色
   showStatus('检测到障碍物!', [1.0, 0.0, 0.0]);  % 红色
```

2.**分步可视化:**
```matlab
   % 在算法关键步骤添加可视化点
   function debugStep(stepName, data)
       persistent stepCounter
       if isempty(stepCounter)
           stepCounter = 1;
       else
           stepCounter = stepCounter + 1;
       end
       
       % 显示步骤名称
       disp(['步骤 ', num2str(stepCounter), ': ', stepName]);
       
       % 可视化数据
       figure('Name', ['调试: ', stepName]);
       switch class(data)
           case 'pointCloud'
               pcshow(data);
               title(['步骤 ', num2str(stepCounter), ': ', stepName]);
           case 'double'
               if size(data, 2) == 3  % 3D点
                   plot3(data(:,1), data(:,2), data(:,3), 'r.');
                   grid on;
                   title(['步骤 ', num2str(stepCounter), ': ', stepName]);
               else
                   % 其他数据类型...
               end
           otherwise
               % 其他数据类型...
       end
       
       % 可选: 暂停等待用户确认
       % input('按Enter继续...');
   end
```

## 7. 故障排除与最佳实践

在开发涉及MATLAB、ROS和Gazebo的复杂机器人系统时，可能会遇到各种问题。本节提供一些常见的故障排除技巧和开发过程中的最佳实践。

### 7.1. ROS-MATLAB通信中的常见问题

网络配置是跨平台（Windows上的MATLAB与VM中的ROS）通信中最容易出现问题的环节。

●   **IP****地址与主机名配置错误**：

○   确保Ubuntu VM中的 ROS_MASTER_URI 指向正确的主机和端口（通常是 http://localhost:11311 或 http://<VM_IP>:11311）。

○   确保Ubuntu VM中的 ROS_IP 或 ROS_HOSTNAME 设置为VM自身的可被主机访问的IP地址。

○   在MATLAB中调用 rosinit 时，第一个参数必须是VM中ROS Master的正确URI (例如 http://<VM_IP>:11311)，并且 NodeHost 参数应设置为主机Windows的IP地址或主机名 1。

○   使用 ping 命令在主机和虚拟机之间互相测试网络连通性。

●   **防火墙阻塞**：Windows防火墙或任何第三方防火墙/杀毒软件可能阻止MATLAB或ROS所需的端口通信。ROS Master使用 11311 端口，但节点间的通信会使用随机分配的高位端口。应配置防火墙允许MATLAB.exe的入站和出站连接，或为特定端口范围（如 11311-11411）创建例外规则 1。

●   **VMware****网络适配器问题**：确保VMware的网络适配器设置为“桥接模式”，并且桥接到了主机正在使用的活动网络接口（如有线或无线网卡）。如果主机有多个网络接口，错误的选择可能导致VM无法接入正确的局域网。

●   **时间同步**：主机和虚拟机之间的时间不同步可能导致TF变换出现问题（“TF_OLD_DATA”错误）。建议在虚拟机中安装并使用NTP服务（如 chrony 或 ntpdate）来同步时间。例如，在VM终端运行 sudo apt install ntpdate 然后 sudo ntpdate pool.ntp.org。

●   **ROS****消息类型不匹配或自定义消息问题**：

○   确保MATLAB和ROS端对同一话题使用的消息类型完全一致。

○   如果使用了自定义ROS消息，必须在MATLAB中正确生成这些消息的定义。对于ROS1，这通常涉及将消息包放置在MATLAB可访问的路径下，并使用 rosgenmsg (旧版) 或确保路径在 rosmessage 函数的搜索范围内。对于ROS2，使用 ros2genmsg 75。

### 7.2. Gazebo仿真调试技巧

●   **模型加载失败或行为异常**：

○   **URDF/SDF****语法错误**：使用 check_urdf <your_robot.urdf> 命令检查URDF文件的语法。仔细检查SDF文件的XML结构。不正确的标签、属性或值都可能导致加载失败或模型显示不正确。

○   **网格文件路径问题**：确保URDF/SDF中引用的 .dae 或 .stl 网格文件路径正确（例如，使用 package:// 或 model:// URI），并且Gazebo能够找到这些文件。

○   **惯性参数不合理**：不正确或缺失的 <inertial> 标签（质量、质心、惯性张量）可能导致模型在Gazebo中行为怪异，如漂浮、穿透或不稳定。特别是当模型为非静态时。

○   **碰撞几何问题**：如果碰撞几何定义不当（例如，过于复杂、自相交、或与视觉几何严重不符），可能导致物理引擎计算错误或仿真卡顿。

●   **传感器插件不工作**：

○   检查URDF/SDF中插件的 <plugin> 标签参数是否正确，如 filename (库文件名)、name (插件实例名)、以及特定于插件的参数（如话题名、更新速率、坐标系名 frameName）。

○   使用 rostopic list 和 rostopic echo <topic_name> 确认传感器数据是否按预期发布到ROS话题。

○   查看Gazebo的终端输出，通常会有插件加载和运行时的错误或警告信息。

●   **物理仿真问题**：

○   如果仿真运行缓慢（real_time_factor 远小于1），尝试减小物理引擎的 max_step_size 或增加 real_time_update_rate（但这会增加CPU负载），或者简化场景复杂度（减少模型数量、使用更简单的碰撞几何）。

○   关节运动异常：检查URDF中关节的 <limit> (范围、速度、力矩) 和 <dynamics> (阻尼、摩擦) 参数。确保 ros_control 控制器配置正确。

●   **Gazebo** **终端输出**：密切关注启动Gazebo和运行仿真时终端窗口的输出信息，其中通常包含重要的错误、警告和调试信息。

### 7.3. 路径规划与重新规划效率提示

●   **调整 manipulatorRRT 参数**：

○   MaxConnectionDistance：影响树扩展的步长。较小值使路径更贴近障碍物但可能增加规划时间；较大值可能规划更快但路径质量较低或无法通过狭窄通道。

○   ValidationDistance：碰撞检测的采样间隔。较小值更安全但增加计算量；较大值可能漏检碰撞。

○   MaxIterations：最大迭代次数。限制规划时间，但如果过小可能找不到路径。

○   根据具体环境和机器人调整这些参数以平衡规划时间和路径质量 45。

●   **简化碰撞环境**：

○   manipulatorRRT 的性能与环境中碰撞对象的数量和复杂度密切相关。将传感器数据（如点云）处理成尽可能少的、简单的碰撞基元（如 collisionBox, collisionSphere）可以显著提高规划速度 45。避免直接使用非常密集的点云作为碰撞对象进行RRT规划。

●   **优化传感器数据处理**：MATLAB中点云的滤波、分割和转换到碰撞对象的过程也需要时间。优化这些步骤（例如，使用更高效的算法、并行处理）可以缩短整个感知-规划周期。

●   **启发式或偏置采样 (RRT进阶)**：如果环境或任务有特定结构，可以考虑使用启发式函数指导RRT的采样过程，或在目标区域附近增加采样偏置（如 manipulatorRRT 的 WorkspaceGoalRegionBias 属性 45），以加速收敛。

●   **重新规划策略**：

○   当需要重新规划时，如果可能，尝试从先前有效路径的某一部分或RRT树的某个分支继续规划，而不是完全从头开始。一些高级RRT变体（如RRT*）更适合动态环境下的重新规划，但 manipulatorRRT 本身可能不直接支持这种增量式重新规划。最直接的方法是基于新的环境信息重新构建规划问题。

○   定义清晰的重新规划触发条件至关重要。过于频繁的重新规划会消耗大量计算资源并可能导致机器人运动不连贯；过于迟钝的触发则可能导致碰撞 67。

### 7.4. 代码管理与版本控制

●   强烈建议使用版本控制系统（如Git）来管理MATLAB代码和ROS包。

●   将代码划分为清晰的模块（例如，MATLAB中的感知模块、规划模块、控制接口模块；ROS中的机器人驱动/控制节点、传感器处理节点等）。

●   编写清晰的文档和注释。

遵循这些故障排除技巧和最佳实践，可以帮助用户更顺利地完成项目开发，并构建一个更稳定、高效的主动避障机械臂运动规划系统。特别需要强调的是，在处理MATLAB与ROS通过网络通信的分布式系统时，耐心细致地检查网络配置往往是解决问题的首要步骤 1。同样，URDF/SDF模型的正确性，尤其是惯性和碰撞部分的定义，对Gazebo仿真的稳定性和真实性有着直接影响，不容忽视。

## 8. 总结与未来展望

### 8.1. 系统实现总结

本实践操作指南详细阐述了如何构建一个基于主动避障的机械臂点到点运动规划系统。该系统整合了Windows 11上的MATLAB与运行在VMware Ubuntu 20.04虚拟机中的ROS Noetic，并通过Gazebo进行三维仿真。核心流程包括：

1. **环境搭建**：配置了MATLAB与ROS之间的网络通信，确保了数据和指令的可靠传输。
2. **自定义机械臂建模**：分别在MATLAB中使用 rigidBodyTree 和D-H参数进行运动学建模，并在Gazebo中使用URDF/SDF进行物理和视觉建模，强调了两者运动学一致性的重要性。
3. **Gazebo****仿真环境构建**：创建了包含自定义机械臂、静态/动态障碍物以及模拟传感器的Gazebo世界。特别推荐使用深度摄像头获取环境三维信息。
4. **核心交互与规划逻辑**：

○   定义了MATLAB与ROS之间通信的话题、消息和服务接口。

○   MATLAB负责：接收并处理来自Gazebo的传感器数据（如点云）以识别障碍物；执行正逆运动学计算；使用 manipulatorRRT 算法进行考虑障碍物的路径规划；使用 trapveltraj 等函数生成平滑的关节轨迹。

○   ROS/Gazebo负责：执行MATLAB发送的轨迹指令（通过 ros_control）；在运动过程中通过传感器持续感知环境；当检测到新障碍物阻碍当前路径时，停止运动并触发MATLAB进行重新规划。

5. **可视化**：利用Gazebo显示物理仿真场景，利用RViz显示ROS消息（如传感器数据、规划路径、TF变换），为调试和监控提供了有力工具。

该系统实现了一个完整的感知-规划-行动迭代循环，机械臂能够响应环境中动态出现的新障碍物，展现了主动避障能力。

### 8.2. 未来工作与潜在增强

本项目为更高级的机器人自主操作打下了坚实的基础。未来可以从以下几个方面进行扩展和增强：

●   **更高级的传感器融合**：集成多种传感器（如视觉、触觉）信息，利用传感器融合算法（如卡尔曼滤波、粒子滤波）提高环境感知的鲁棒性和准确性。

●   **高级重新规划算法**：

○   研究和实现更适合动态环境的重新规划算法，如RRT* (Optimal RRT) 69、D* Lite等，这些算法能够更有效地利用先前的规划信息，在环境变化时快速生成新的优化路径。

○   探索如OpenMORE库 67 提供的连续重新规划框架，以实现更平滑、更实时的机器人响应。

●   **基于学习的方法**：

○   引入强化学习或模仿学习来优化路径规划策略或避障行为，使机器人能够从经验中学习并适应更复杂的环境。

○   使用机器学习进行物体识别和场景理解，以支持更复杂的任务（如基于语义的抓取）。

●   **精细化的夹爪控制与物体交互**：

○   为夹爪添加更精细的控制逻辑，实现对不同形状和大小物体的稳定抓取。

○   集成力/力矩传感器，实现柔顺控制和力控抓取。

●   **动态障碍物运动预测**：如果环境中有可移动的障碍物（如其他机器人或人），可以加入运动预测模块，使路径规划更具前瞻性，避免潜在的未来碰撞。

●   **从仿真到实际硬件的迁移**：

○   逐步将MATLAB和ROS中的算法部署到真实的机械臂硬件上。

○   处理实际传感器噪声、标定误差、执行器延迟等真实世界问题。

○   确保安全协议和紧急停止机制的可靠性。

●   **用户界面增强**：开发更友好的用户界面，方便用户设置任务目标、监控机器人状态和调整系统参数。

通过这些增强，可以进一步提升机械臂的自主性、智能性和在复杂动态环境中的作业能力。本指南所构建的模块化系统（MATLAB负责高级规划，ROS/Gazebo负责低级控制与仿真）为这些未来扩展提供了良好的起点和灵活性。

#### 引用的著作

1. Connect to ROS Network and Establish ... - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/ros/gs/ros1-nodes.html
2. How can I connect MATLAB on Windows to ROS2 on VirtualBox Ubuntu? - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/matlabcentral/answers/2174723-how-can-i-connect-matlab-on-windows-to-ros2-on-virtualbox-ubuntu
3. ROS Noetic and ROS 2 Humble and Gazebo - MATLAB & Simulink - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/support/product/robotics/ros2-vm-installation-instructions-v9.html
4. rosbridge_suite - ROS Wiki, 访问时间为 五月 9, 2025， http://wiki.ros.org/rosbridge_suite
5. Matlab-Ros-Interface/ros_websocket.m at master · mozcelikors ..., 访问时间为 五月 9, 2025， https://github.com/mozcelikors/Matlab-Ros-Interface/blob/master/ros_websocket.m
6. Matlab-ROS Interface | Mustafa Özçelikörs, 访问时间为 五月 9, 2025， http://www.mozcelikors.com/projects_matlabrosinterface.html
7. Using a websocket connection in Matlab - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/matlabcentral/answers/122445-using-a-websocket-connection-in-matlab
8. rigidBodyTree - Create tree-structured robot - MATLAB - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/ref/rigidbodytree.html
9. rigidBody - Create a rigid body - MATLAB - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/ref/rigidbody.html
10. Implementation of the Denavit-Hartenberg (DH) parameters in ..., 访问时间为 五月 9, 2025， https://www.mathworks.com/matlabcentral/fileexchange/56917-implementation-of-the-denavit-hartenberg-dh-parameters-in-matlab
11. Denavit-Hartenberg models — Robotics Toolbox for Python documentation, 访问时间为 五月 9, 2025， https://petercorke.github.io/robotics-toolbox-python/arm_dh.html
12. Setting Up The SDF - Gazebo — Nav2 1.0.0 documentation, 访问时间为 五月 9, 2025， https://docs.nav2.org/setup_guides/sdf/setup_sdf.html
13. How to Model a Robotic Arm With a URDF File – ROS 2, 访问时间为 五月 9, 2025， https://automaticaddison.com/how-to-model-a-robotic-arm-with-a-urdf-file-ros-2/
14. Building a Robot Arm with URDF: A Step-by-Step Tutorial - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=vwOVxbRJa6k
15. Create and Visualize a Mobile Robot with URDF – ROS 2 Jazzy - Automatic Addison, 访问时间为 五月 9, 2025， https://automaticaddison.com/create-and-visualize-a-mobile-robot-with-urdf-ros-2-jazzy/
16. [Gazebo in 5 minutes] 004 - How to create a gazebo model using SDF - The Construct, 访问时间为 五月 9, 2025， https://www.theconstruct.ai/gazebo-5-minutes-004-create-gazebo-model-using-sdf/
17. Tutorial 5: Simulation — 240AR060 - Introduction to ROS, 访问时间为 五月 9, 2025， https://sir.upc.edu/projects/ros2tutorials/5-simulation/index.html
18. Spawn a URDF model in Gazebo with ROS2 | ROS2 Developers Open Class #142, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=mDS_M95MQGA&pp=0gcJCdgAo7VqN5tD
19. Manipulation in Gazebo Ignition - Clearpath Robotics Documentation, 访问时间为 五月 9, 2025， https://docs.clearpathrobotics.com/docs/ros/tutorials/manipulation/gazebo/
20. Spawn URDF — Gazebo ionic documentation, 访问时间为 五月 9, 2025， https://gazebosim.org/docs/latest/spawn_urdf/
21. Configure Gazebo and Simulink for Co-simulation of a Manipulator Robot - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/ug/configure-gazebo-for-co-simulation-of-manipulator.html
22. [Gazebo in 5 minutes] 002 - How to add gazebo models to a simulation - The Construct, 访问时间为 五月 9, 2025， https://www.theconstruct.ai/gazebo-5-minutes-002-add-gazebo-models-simulation/
23. Specifying pose — Documentation - SDFormat, 访问时间为 五月 9, 2025， http://sdformat.org/tutorials?tut=specify_pose
24. [ROS Q&A] 114 - Set robot initial pose in ROS launch file - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=9ggSfKE0v94
25. How to set the initial camera pose in Gazebo - LXRobotics, 访问时间为 五月 9, 2025， https://lxrobotics.com/blog/set-initial-camera-pose-gazebo/
26. How-to set the initial camera pose in Gazebo - docs.lxrobotics.com, 访问时间为 五月 9, 2025， https://docs.lxrobotics.com/knowledge-base/gazebo/set-initial-camera-pose-gazebo
27. Tutorial : Building a world - Gazebo, 访问时间为 五月 9, 2025， https://classic.gazebosim.org/tutorials?tut=build_world&ver=1.9
28. [Gazebo in 5 minutes] 002 - How to add gazebo models to a ..., 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=tIJRxkaAZtA&pp=0gcJCdgAo7VqN5tD
29. Tutorial : Attach Meshes - Gazebo, 访问时间为 五月 9, 2025， https://classic.gazebosim.org/tutorials?tut=attach_meshes
30. TurtleBot4Lessons/units/Unit01-ROS-2-Basics/L02-Gazebo-World/U01-L02-Empty-World.md at main - GitHub, 访问时间为 五月 9, 2025， https://github.com/turtlebot/TurtleBot4Lessons/blob/main/units/Unit01-ROS-2-Basics/L02-Gazebo-World/U01-L02-Empty-World.md
31. MOGI-ROS/Week-5-6-Gazebo-sensors - GitHub, 访问时间为 五月 9, 2025， https://github.com/MOGI-ROS/Week-5-6-Gazebo-sensors
32. MOGI-ROS/Week-3-4-Gazebo-basics: Introduction to URDF and Gazebo Harmonic with ROS2 Jazzy - GitHub, 访问时间为 五月 9, 2025， https://github.com/MOGI-ROS/Week-3-4-Gazebo-basics
33. Tutorial 8: Simulation - Sensors — 240AR060 - Introduction to ROS, 访问时间为 五月 9, 2025， https://sir.upc.edu/projects/rostutorials/8-gazebo_sensors_tutorial/index.html
34. Tutorial : ROS Depth Camera Integration - Gazebo Classic, 访问时间为 五月 9, 2025， https://classic.gazebosim.org/tutorials?tut=ros_depth_camera
35. How to use Cameras in ROS (Sim Camera and Pi Camera) - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=A3nw2M47K50
36. [ROS] Using Gazebo Camera Plug-in - YouTube, 访问时间为 五月 9, 2025， https://m.youtube.com/watch?v=UMEE5HYQ8VU
37. Setting Up Sensors - Gazebo — Nav2 1.0.0 documentation, 访问时间为 五月 9, 2025， https://docs.nav2.org/setup_guides/sensors/setup_sensors_gz.html
38. [ROS] Using gazebo Laser Scan Plugin - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=M_pzenkPZfE
39. LiDAR Plugin for Gazebo in ROS2 Humble - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=g9y5-9Z94u8
40. [ROS Projects] – Exploring ROS using a 2 Wheeled Robot - The Construct, 访问时间为 五月 9, 2025， https://www.theconstruct.ai/ros-projects-exploring-ros-using-2-wheeled-robot-part-1/
41. Setting Up Sensors - Gazebo Classic — Nav2 1.0.0 documentation, 访问时间为 五月 9, 2025， https://docs.nav2.org/setup_guides/sensors/setup_sensors_gz_classic.html
42. Pick-and-Place Workflow in Gazebo Using Point-Cloud Processing ..., 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/ug/pick-and-place-gazebo-with-point-clouds-and-rrt.html
43. Gazebo model collision plugin - ROS Discourse, 访问时间为 五月 9, 2025， https://discourse.ros.org/t/gazebo-model-collision-plugin/10814
44. Manipulator Planning - MATLAB & Simulink - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/manipulator-planning.html
45. manipulatorRRT - Plan motion for rigid body tree using bidirectional RRT - MATLAB, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/ref/manipulatorrrt.html
46. How does Forward kinematik work in Robotics System Toolbox? - MATLAB Answers, 访问时间为 五月 9, 2025， https://www.mathworks.com/matlabcentral/answers/2144814-how-does-forward-kinematik-work-in-robotics-system-toolbox
47. What Is Inverse Kinematics? - MATLAB & Simulink - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/discovery/inverse-kinematics.html
48. trapveltraj - MathWorks, 访问时间为 五月 9, 2025， [https://www.mathworks.com/help//releases/R2021a/robotics/ref/trapveltraj.html](https://www.mathworks.com/help/releases/R2021a/robotics/ref/trapveltraj.html)
49. Trajectory Generation and Following - MathWorks, 访问时间为 五月 9, 2025， [https://www.mathworks.com/help//releases/R2021a/robotics/trajectory-generation.html](https://www.mathworks.com/help/releases/R2021a/robotics/trajectory-generation.html)
50. Robotics System Toolbox Documentation - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/robotics/index.html
51. Robotics System Toolbox - MathWorks, 访问时间为 五月 9, 2025， [https://www.mathworks.com/help//releases/R2021a/robotics/index.html](https://www.mathworks.com/help/releases/R2021a/robotics/index.html)
52. Plan Mobile Robot Paths Using RRT - MATLAB & Simulink - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/nav/ug/plan-mobile-robot-paths-using-rrt.html
53. Robotics System Toolbox - MATLAB - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/products/robotics.html
54. Robotics System Toolbox — Examples - MathWorks, 访问时间为 五月 9, 2025， [https://www.mathworks.com/help//releases/R2021a/robotics/examples.html?s_cid=doc_ftr](https://www.mathworks.com/help/releases/R2021a/robotics/examples.html?s_cid=doc_ftr)
55. Setting up a robot simulation (Gazebo) — ROS 2 Documentation: Humble documentation, 访问时间为 五月 9, 2025， https://docs.ros.org/en/humble/Tutorials/Advanced/Simulators/Gazebo/Gazebo.html
56. Tutorial 10: Robot Control — 240AR060 - Introduction to ROS, 访问时间为 五月 9, 2025， https://sir.upc.edu/projects/rostutorials/10-gazebo_control_tutorial/index.html
57. ROS2 Control Gazebo Tutorial Robot Simulation (Custom Robot Arm TeslaBot!) - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=PM_1Nb9u-N0
58. Path planning in ROS with visualization GUIs Rviz and Gazebo. - Sites@Duke Express, 访问时间为 五月 9, 2025， https://sites.duke.edu/memscapstone/path-planning-in-ros-with-visualization-guis-rviz-and-gazebo/
59. 9 Gazebo Joint Control Plugin - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=z_eySXwICrs
60. Gazebo Joints Control in ROS2 - The Construct, 访问时间为 五月 9, 2025， https://www.theconstruct.ai/gazebo-joints-control-in-ros2/
61. [ROS Q&A] 149 - How to command joint position of a robot in ROS using Python?, 访问时间为 五月 9, 2025， https://www.theconstruct.ai/ros-qa-149-how-to-command-joint-position-of-a-robot-in-ros-using-python/
62. Exploring Adversarial Obstacle Attacks in Search-based Path Planning for Autonomous Mobile Robots - arXiv, 访问时间为 五月 9, 2025， https://arxiv.org/html/2504.06154v1
63. Path Following with Obstacle Avoidance in Simulink® - MATLAB & - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/nav/ug/path-following-with-obstacle-avoidance-in-simulink.html
64. robot_collision_checking: A Lightweight ROS 2 Interface to FCL (Flexible Collision Library), 访问时间为 五月 9, 2025， https://joss.theoj.org/papers/10.21105/joss.07473.pdf
65. Collision-free path planning for industrial robot applications - Webthesis - Politecnico di Torino, 访问时间为 五月 9, 2025， https://webthesis.biblio.polito.it/29533/1/tesi.pdf
66. [ROS Q&A] 154 - How to Detect Collisions with static objects in Gazebo - YouTube, 访问时间为 五月 9, 2025， https://www.youtube.com/watch?v=KidqFt1mymE
67. OpenMORE: an open-source tool for sampling-based path replanning in ROS, 访问时间为 五月 9, 2025， https://www.researchgate.net/publication/374679219_OpenMORE_an_open-source_tool_for_sampling-based_path_replanning_in_ROS
68. OpenMORE: an open-source tool for sampling-based path replanning in ROS - arXiv, 访问时间为 五月 9, 2025， https://arxiv.org/html/2311.18406v1
69. README.md - ROS Motion Planning - GitHub, 访问时间为 五月 9, 2025， https://github.com/ai-winter/ros_motion_planning/blob/master/README.md
70. IMPLEMENTATION AND EVALUATION OF AN OBSTACLE AVOIDANCE SYSTEM IN A COLLABORATIVE ROBOT - UPCommons, 访问时间为 五月 9, 2025， https://upcommons.upc.edu/bitstream/handle/2117/407206/183195.pdf;jsessionid=401891D63DC3219CF61F830053CC4183?sequence=2
71. Publish Variable-Length Nested ROS Messages in MATLAB, 访问时间为 五月 9, 2025， [https://www.mathworks.com/help//releases/R2021a/ros/ug/publish-variable-length-nested-ros-messages.html](https://www.mathworks.com/help/releases/R2021a/ros/ug/publish-variable-length-nested-ros-messages.html)
72. Lab 6.3: Visualizations in ROS with RViz - HKU Robocon Tutorials, 访问时间为 五月 9, 2025， https://docs.m2stud.io/cs/ros_additional/06-L3-rviz/
73. Visualize Messages from Live ROS or ROS 2 Topics - MATLAB & Simulink - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/ros/ug/visualize-messages-from-live-network.html
74. Simultaneous Path Planning of Planner Control RRT Algorithm and Turtlebot3-Burger Robot in MATLAB and Gazebo - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/matlabcentral/answers/2005082-simultaneous-path-planning-of-planner-control-rrt-algorithm-and-turtlebot3-burger-robot-in-matlab-an
75. ros2genmsg - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/ros/ref/ros2genmsg.html
76. ROS Toolbox Documentation - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/help/ros/index.html
77. ROS Toolbox - MATLAB - MathWorks, 访问时间为 五月 9, 2025， https://www.mathworks.com/products/ros.html